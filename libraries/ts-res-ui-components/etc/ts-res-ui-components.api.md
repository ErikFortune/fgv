## API Report File for "@fgv/ts-res-ui-components"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Bundle } from '@fgv/ts-res';
import { Config } from '@fgv/ts-res';
import { FileTree } from '@fgv/ts-utils';
import { Import } from '@fgv/ts-res';
import { JsonCompatible } from '@fgv/ts-json-base';
import { JsonValue } from '@fgv/ts-json-base';
import { Logging } from '@fgv/ts-utils';
import { MessageLogLevel } from '@fgv/ts-utils';
import { Qualifiers } from '@fgv/ts-res';
import { QualifierTypes } from '@fgv/ts-res';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';
import { ReactNode } from 'react';
import { ResourceJson } from '@fgv/ts-res';
import { Resources } from '@fgv/ts-res';
import { ResourceTypes } from '@fgv/ts-res';
import { Result } from '@fgv/ts-utils';
import { Runtime } from '@fgv/ts-res';
import { Success } from '@fgv/ts-utils';

// @public
function analyzeFilteredResources(originalResourceIds: string[], filteredProcessedResources: IProcessedResources, originalProcessedResources: IProcessedResources): IFilterResult;

// Warning: (ae-forgotten-export) The symbol "IBooleanCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const BooleanCell: React_2.FC<IBooleanCellProps>;

// @public
const clearAllGridValidationErrors: () => void;

// @public
function cloneConfiguration(config: Config.Model.ISystemConfiguration): Config.Model.ISystemConfiguration;

// @public
export const CompiledView: React_2.FC<ICompiledViewProps>;

declare namespace ConfigurationTools {
    export {
        ConfigurationView,
        QualifierTypeEditForm,
        QualifierEditForm,
        ResourceTypeEditForm,
        HierarchyEditor,
        useIConfigurationState,
        getDefaultConfiguration,
        validateConfiguration,
        cloneConfiguration,
        exportConfiguration,
        importConfiguration,
        IConfigurationViewProps
    }
}
export { ConfigurationTools }

// @public
export const ConfigurationView: React_2.FC<IConfigurationViewProps>;

// @public
class ConsoleUserLogger extends Logging.LoggerBase implements IUserLogger {
    constructor(logLevel?: Logging.ReporterLogLevel);
    protected _log(message: string, level: MessageLogLevel): Success<string | undefined>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    success(message?: unknown, ...parameters: unknown[]): Success<string | undefined>;
}

// Warning: (ae-forgotten-export) The symbol "ObservabilityTools_2" needs to be exported by the entry point index.d.ts
//
// @internal (undocumented)
function convertImportedDirectoryToFileTree(directory: IImportedDirectory, o11y?: ObservabilityTools_2.IObservabilityContext): FileTree.FileTree;

// @public
function createConsoleObservabilityContext(diagLogLevel?: Logging.ReporterLogLevel, userLogLevel?: Logging.ReporterLogLevel): IObservabilityContext;

// @public
const createFilteredResourceManagerSimple: (originalSystem: IProcessedResources["system"], partialContext: Record<string, string | undefined>, options?: IFilterOptions) => Promise<Result<IProcessedResources>>;

// @public
function createNoOpObservabilityContext(diagLogLevel?: Logging.ReporterLogLevel, userLogLevel?: Logging.ReporterLogLevel): IObservabilityContext;

// @public
function createResolverWithContext(processedResources: IProcessedResources, contextValues: Record<string, string | undefined>, options?: IResolutionOptions): Result<Runtime.ResourceResolver>;

// @internal (undocumented)
function createSimpleContext(qualifiers: Qualifiers.IReadOnlyQualifierCollector, values: Record<string, string | undefined>): Result<Runtime.ValidatingSimpleContextQualifierProvider>;

// @public
function createTimestamp(customFormat?: string): string;

// @internal (undocumented)
function createTsResSystemFromConfig(systemConfig?: Config.Model.ISystemConfiguration, qualifierTypeFactory?: Config.IConfigInitFactory<QualifierTypes.Config.IAnyQualifierTypeConfig, QualifierTypes.QualifierType>, resourceTypeFactory?: Config.IConfigInitFactory<ResourceTypes.Config.IResourceTypeConfig, ResourceTypes.ResourceType>): Result<{
    qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
    qualifiers: Qualifiers.IReadOnlyQualifierCollector;
    resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
    resourceManager: Resources.ResourceManagerBuilder;
    importManager: Import.ImportManager;
    contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
}>;

// Warning: (ae-forgotten-export) The symbol "IMessage" needs to be exported by the entry point index.d.ts
//
// @public
function createViewStateObservabilityContext(addMessage: (type: IMessage['type'], message: string) => void, diagLogLevel?: Logging.ReporterLogLevel, userLogLevel?: Logging.ReporterLogLevel): IObservabilityContext;

// @public
const DefaultObservabilityContext: IObservabilityContext;

// @public
const defaultResourceSelector: ResourceSelector;

// @public
function deriveFullId(rootPath: string, leafId: string): Result<string>;

// @public
function deriveLeafId(fullResourceId: string): Result<string>;

// @public
function detectObservabilityContextType(context: IObservabilityContext): ObservabilityContextType;

// @public
function downloadBundle(data: unknown, resourceCount?: number, configName?: string): Result<void>;

// @public
function downloadCompiledResources(data: unknown, resourceCount?: number): Result<void>;

// @public
function downloadFile(data: unknown, type: string, options?: IDownloadOptions): Result<void>;

// @public
function downloadResources(data: unknown, resourceCount?: number, collectionName?: string): Result<void>;

// @public
function downloadSourceResources(data: unknown, resourceCount?: number): Result<void>;

declare namespace DownloadTools {
    export {
        DownloadUtils
    }
}
export { DownloadTools }

// @public
function downloadTsResJson(data: unknown, type: string): Result<void>;

declare namespace DownloadUtils {
    export {
        createTimestamp,
        generateFilename,
        downloadFile,
        downloadTsResJson,
        downloadBundle,
        downloadResources,
        downloadCompiledResources,
        downloadSourceResources,
        IDownloadOptions
    }
}

// Warning: (ae-forgotten-export) The symbol "IDropdownCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const DropdownCell: React_2.FC<IDropdownCellProps>;

// Warning: (ae-forgotten-export) The symbol "IEditableGridCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const EditableGridCell: React_2.FC<IEditableGridCellProps>;

// @public
const EditableJsonView: React_2.FC<IEditableJsonViewProps>;

// @public
function evaluateConditionsForCandidate(resolver: Runtime.ResourceResolver, candidateIndex: number, compiledResource: ResourceJson.Compiled.ICompiledResource, compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection): IConditionEvaluationResult[];

// @internal (undocumented)
function exportAsJson(data: JsonValue, filename: string): void;

// Warning: (ae-forgotten-export) The symbol "IConfigurationExportOptions" needs to be exported by the entry point index.d.ts
//
// @public
function exportConfiguration(config: Config.Model.ISystemConfiguration, options?: IConfigurationExportOptions): Result<string>;

// @internal (undocumented)
function exportUsingFileSystemAPI(data: JsonValue, suggestedName: string, description?: string): Promise<boolean>;

// @internal (undocumented)
function filesToDirectory(files: IImportedFile[]): IImportedDirectory;

declare namespace FilterTools {
    export {
        FilterView,
        useFilterState,
        createFilteredResourceManagerSimple,
        analyzeFilteredResources,
        hasFilterValues,
        getFilterSummary,
        IFilterOptions,
        IFilterState,
        IFilterActions,
        IFilterViewProps,
        IFilterResult,
        IFilteredResource
    }
}
export { FilterTools }

// @public
export const FilterView: React_2.FC<IFilterViewProps>;

// @public
function generateFilename(baseFilename: string, type?: string, options?: IDownloadOptions): Result<string>;

// @public
const getAllGridValidationErrors: () => Record<string, Record<string, string>>;

// @public
function getAvailableQualifiers(processedResources: IProcessedResources): string[];

// @public
function getDefaultConfiguration(): Config.Model.ISystemConfiguration;

// @internal (undocumented)
function getDefaultSystemConfiguration(): Config.Model.ISystemConfiguration;

// @public
function getFilterSummary(values: Record<string, string | undefined>): string;

// @public
function getPendingAdditionsByType(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>, resourceType: string): Array<{
    id: string;
    resource: ResourceJson.Json.ILooseResourceDecl;
}>;

// @public
function getPendingResourceStats(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): {
    totalCount: number;
    byType: Record<string, number>;
    resourceIds: string[];
};

// @public
function getPendingResourceTypes(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): string[];

// @public
type GridResourceSelector = {
    type: 'ids';
    resourceIds: string[];
} | {
    type: 'prefix';
    prefix: string;
} | {
    type: 'suffix';
    suffix: string;
} | {
    type: 'resourceTypes';
    types: string[];
} | {
    type: 'pattern';
    pattern: string;
} | {
    type: 'all';
} | {
    type: 'custom';
    selector: ICustomResourceSelector;
};

// Warning: (ae-forgotten-export) The symbol "IGridSelectorProps" needs to be exported by the entry point index.d.ts
//
// @public
const GridSelector: React_2.FC<IGridSelectorProps>;

declare namespace GridTools {
    export {
        GridView,
        MultiGridView,
        ResourceGrid,
        EditableGridCell,
        SharedContextControls,
        GridSelector,
        StringCell,
        BooleanCell,
        TriStateCell,
        DropdownCell,
        ResourceSelector,
        defaultResourceSelector,
        selectResources,
        validateCellValue,
        ValidationPatterns,
        ValidationFunctions,
        GridValidationState,
        hasGridValidationErrors,
        getAllGridValidationErrors,
        clearAllGridValidationErrors,
        IGridViewProps,
        IMultiGridViewProps,
        IGridViewInitParams,
        IGridColumnDefinition,
        IGridDropdownOption,
        IGridCellValidation,
        GridResourceSelector,
        ICustomResourceSelector,
        IGridPresentationOptions,
        IResourceTypeColumnMapping,
        IGridCellProps,
        IGridCellEditorProps
    }
}
export { GridTools }

// @public
class GridValidationState {
    clearAll(): void;
    clearCell(resourceId: string, columnId: string): void;
    clearResource(resourceId: string): void;
    get errorCount(): number;
    getAllErrors(): Array<{
        resourceId: string;
        columnId: string;
        error: string;
    }>;
    getCellError(resourceId: string, columnId: string): string | null;
    getResourceErrors(resourceId: string): Map<string, string>;
    hasCellError(resourceId: string, columnId: string): boolean;
    get hasErrors(): boolean;
    setCellError(resourceId: string, columnId: string, error: string | null): void;
}

// @public
export const GridView: React_2.FC<IGridViewProps>;

// @public
function hasFilterValues(values: Record<string, string | undefined>): boolean;

// @public
const hasGridValidationErrors: () => boolean;

// @public
function hasPendingContextChanges(contextValues: Record<string, string | undefined>, pendingContextValues: Record<string, string | undefined>): boolean;

// Warning: (ae-forgotten-export) The symbol "IHierarchyEditorProps" needs to be exported by the entry point index.d.ts
//
// @public
const HierarchyEditor: React_2.FC<IHierarchyEditorProps>;

// @public
interface ICandidateInfo {
    candidate: Runtime.IResourceCandidate;
    candidateIndex: number;
    conditionEvaluations?: IConditionEvaluationResult[];
    conditionSetKey: string | null;
    isDefaultMatch: boolean;
    matched: boolean;
    matchType: 'match' | 'matchAsDefault' | 'noMatch';
}

// @public
interface ICompiledViewProps extends IViewBaseProps {
    filterResult?: IFilterResult | null;
    filterState?: IFilterState;
    onExport?: (data: ResourceJson.Compiled.ICompiledResourceCollection | Bundle.IBundle, type: 'json' | 'bundle') => void;
    pickerOptions?: IResourcePickerOptions;
    resources?: IExtendedProcessedResources | null;
    useNormalization?: boolean;
}

// @public
interface IConditionEvaluationResult {
    conditionIndex: number;
    conditionValue: string | undefined;
    matched: boolean;
    matchType: 'match' | 'matchAsDefault' | 'noMatch';
    operator: string;
    qualifierName: string;
    qualifierValue: string | undefined;
    score: number;
    scoreAsDefault?: number;
}

// @public
interface IConfigurationViewProps extends IViewBaseProps {
    configuration?: Config.Model.ISystemConfiguration | null;
    hasUnsavedChanges?: boolean;
    onConfigurationChange?: (config: Config.Model.ISystemConfiguration) => void;
    onSave?: (config: Config.Model.ISystemConfiguration) => void;
}

// @public
interface ICreatePendingResourceParams<T = unknown, TV extends JsonCompatible<T> = JsonCompatible<T>> {
    id: string;
    json?: TV;
    resourceTypeName: string;
}

// @public
interface ICustomResourceSelector {
    displayName?: string;
    id: string;
    select: (resources: IProcessedResources) => string[];
}

// @public
interface IDownloadOptions {
    baseFilename?: string;
    extension?: string;
    filenameTransformer?: (baseFilename: string) => string;
    includeTimestamp?: boolean;
    mimeType?: string;
    timestampFormat?: string;
}

// @public
interface IEditableJsonViewProps {
    className?: string;
    disabled?: boolean;
    editedValue?: JsonValue;
    isEdited?: boolean;
    onCancel?: (resourceId: string) => void;
    onSave?: (resourceId: string, editedValue: JsonValue, originalValue: JsonValue) => void;
    resourceId: string;
    value: JsonValue;
}

// @public
interface IEditedResourceInfo<T = unknown, TV extends JsonCompatible<T> = JsonCompatible<T>> {
    // (undocumented)
    editedValue: TV;
    // (undocumented)
    originalValue: TV;
    resourceId: string;
    // (undocumented)
    timestamp: Date;
}

// @public
interface IExtendedProcessedResources extends IProcessedResources {
    activeConfiguration?: Config.Model.ISystemConfiguration | null;
    bundleMetadata?: Bundle.IBundleMetadata | null;
    isLoadedFromBundle?: boolean;
}

// @public
interface IFilterActions {
    applyFilterValues: () => void;
    resetFilterValues: () => void;
    updateFilterEnabled: (enabled: boolean) => void;
    updateFilterValues: (values: Record<string, string | undefined>) => void;
    updateReduceQualifiers: (reduceQualifiers: boolean) => void;
}

// @public
interface IFilteredResource {
    filteredCandidateCount: number;
    hasWarning: boolean;
    id: string;
    originalCandidateCount: number;
}

// @public
interface IFilterOptions {
    enableDebugLogging?: boolean;
    partialContextMatch?: boolean;
    reduceQualifiers?: boolean;
}

// @public
interface IFilterResult {
    error?: string;
    filteredResources: IFilteredResource[];
    processedResources?: IProcessedResources;
    success: boolean;
    warnings: string[];
}

// @public
interface IFilterState {
    appliedValues: Record<string, string | undefined>;
    enabled: boolean;
    hasPendingChanges: boolean;
    reduceQualifiers: boolean;
    values: Record<string, string | undefined>;
}

// @public
interface IFilterViewProps extends IViewBaseProps {
    contextOptions?: IResolutionContextOptions;
    filterActions: IFilterActions;
    filterResult?: IFilterResult | null;
    filterState: IFilterState;
    onFilterResult?: (result: IFilterResult | null) => void;
    pickerOptions?: IResourcePickerOptions;
    resources?: IProcessedResources | null;
}

// @public
interface IGridCellEditorProps extends IGridCellProps {
    disabled?: boolean;
    editedValue?: JsonValue;
    onCancel: () => void;
    onSave: (resourceId: string, newValue: JsonValue, originalValue: JsonValue) => void;
}

// @public
interface IGridCellProps {
    className?: string;
    column: IGridColumnDefinition;
    isEdited: boolean;
    resolvedValue: JsonValue;
    resourceId: string;
    value: JsonValue;
}

// @public
interface IGridCellValidation {
    custom?: (value: JsonValue) => string | null;
    maxLength?: number;
    minLength?: number;
    pattern?: RegExp;
    required?: boolean;
}

// @public
interface IGridColumnDefinition {
    allowCustomValue?: boolean;
    cellEditor?: React.ComponentType<IGridCellEditorProps>;
    cellRenderer?: React.ComponentType<IGridCellProps>;
    cellType?: 'string' | 'boolean' | 'tristate' | 'dropdown' | 'custom';
    dataPath: string | string[];
    dropdownOptions?: IGridDropdownOption[] | (() => Promise<IGridDropdownOption[]>);
    editable?: boolean;
    id: string;
    sortable?: boolean;
    title: string;
    triStateLabels?: {
        trueLabel: string;
        falseLabel: string;
        undefinedLabel: string;
    };
    triStatePresentation?: 'checkbox' | 'dropdown';
    validation?: IGridCellValidation;
    width?: number;
}

// @public
interface IGridDropdownOption {
    disabled?: boolean;
    label: string;
    value: string;
}

// @public
interface IGridPresentationOptions {
    className?: string;
    enableFiltering?: boolean;
    enableSorting?: boolean;
    pageSize?: number;
    showRowNumbers?: boolean;
    showSummaryRow?: boolean;
}

// @public
interface IGridViewInitParams {
    columnMapping: IResourceTypeColumnMapping[];
    description?: string;
    id: string;
    presentationOptions?: IGridPresentationOptions;
    resourceSelection: GridResourceSelector;
    title: string;
}

// @public
interface IGridViewProps extends IViewBaseProps {
    availableQualifiers?: string[];
    contextOptions?: IResolutionContextOptions;
    filterResult?: IFilterResult | null;
    filterState?: IFilterState;
    gridConfig: IGridViewInitParams;
    resolutionActions?: IResolutionActions;
    resolutionState?: IResolutionState;
    resources?: IProcessedResources | null;
    showChangeControls?: boolean;
    showContextControls?: boolean;
}

// @public
interface IImportedDirectory {
    files: IImportedFile[];
    name: string;
    path?: string;
    subdirectories?: IImportedDirectory[];
}

// @public
interface IImportedFile {
    content: string;
    name: string;
    path?: string;
    type?: string;
}

// @public
interface IImportViewProps extends IViewBaseProps {
    acceptedFileTypes?: string[];
    importError?: string | null;
    onBundleImport?: (bundle: Bundle.IBundle) => void;
    onImport?: (data: IImportedDirectory | IImportedFile[]) => void;
    onZipImport?: (zipData: IImportedDirectory | IImportedFile[], config?: Config.Model.ISystemConfiguration) => void;
}

// @public
interface IMessage_2 {
    id: string;
    message: string;
    timestamp: Date;
    type: 'info' | 'warning' | 'error' | 'success';
}

// @public
interface IMessagesWindowProps {
    className?: string;
    messages: IMessage_2[];
    onClearMessages: () => void;
}

// @public
function importConfiguration(data: string): Result<Config.Model.ISystemConfiguration>;

declare namespace ImportTools {
    export {
        ImportView,
        readFilesFromInput,
        filesToDirectory,
        exportAsJson,
        exportUsingFileSystemAPI,
        IImportedFile,
        IImportedDirectory,
        IImportViewProps
    }
}
export { ImportTools }

// @public
export const ImportView: React_2.FC<IImportViewProps>;

// @public
interface IMultiGridViewProps extends IViewBaseProps {
    allowGridReordering?: boolean;
    availableQualifiers?: string[];
    contextOptions?: IResolutionContextOptions;
    defaultActiveGrid?: string;
    filterResult?: IFilterResult | null;
    filterState?: IFilterState;
    gridConfigurations: IGridViewInitParams[];
    resolutionActions?: IResolutionActions;
    resolutionState?: IResolutionState;
    resources?: IProcessedResources | null;
    tabsPresentation?: 'tabs' | 'cards' | 'accordion' | 'dropdown';
}

// @public
interface IObservabilityContext {
    readonly diag: Logging.ILogger;
    readonly user: IUserLogger;
}

// @public
export interface IObservabilityProviderProps {
    children: ReactNode;
    observabilityContext?: ObservabilityTools_2.IObservabilityContext;
}

// @public
export interface IOrchestratorActions {
    // (undocumented)
    addMessage: (type: IMessage['type'], message: string) => void;
    // (undocumented)
    applyConfiguration: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    applyFilter: () => Promise<IFilterResult | null>;
    // (undocumented)
    applyPendingResources: () => Promise<Result<{
        appliedCount: number;
        existingResourceEditCount: number;
        pendingResourceEditCount: number;
        newResourceCount: number;
        deletionCount: number;
    }>>;
    // (undocumented)
    applyResolutionContext: (hostManagedValues?: Record<string, string | undefined>) => Result<void>;
    // (undocumented)
    cancelNewResource: () => void;
    // (undocumented)
    clearMessages: () => void;
    // (undocumented)
    clearResourceEdits: () => Result<{
        clearedCount: number;
    }>;
    // (undocumented)
    clearResources: () => void;
    // (undocumented)
    createPendingResource: (params: ICreatePendingResourceParams) => Result<void>;
    // (undocumented)
    discardPendingResources: () => void;
    // (undocumented)
    discardResourceEdits: () => Result<{
        discardedCount: number;
    }>;
    // (undocumented)
    exportBundle: () => void;
    // (undocumented)
    exportCompiled: () => void;
    // (undocumented)
    exportSource: () => void;
    // (undocumented)
    getEditedValue: (resourceId: string) => JsonValue | undefined;
    // (undocumented)
    hasResourceEdit: (resourceId: string) => boolean;
    // (undocumented)
    importBundle: (bundle: Bundle.IBundle) => Promise<void>;
    // (undocumented)
    importDirectory: (directory: IImportedDirectory) => Promise<void>;
    // (undocumented)
    importDirectoryWithConfig: (directory: IImportedDirectory, config: Config.Model.ISystemConfiguration) => Promise<void>;
    // (undocumented)
    importFiles: (files: IImportedFile[]) => Promise<void>;
    // (undocumented)
    markResourceForDeletion: (resourceId: string) => void;
    // (undocumented)
    o11y: IObservabilityContext;
    // (undocumented)
    removePendingResource: (resourceId: string) => Result<void>;
    // (undocumented)
    resetFilter: () => void;
    // (undocumented)
    resetResolutionCache: () => Result<void>;
    // (undocumented)
    resolveResource: (resourceId: string, context?: Record<string, string>) => Result<JsonValue>;
    // (undocumented)
    saveNewResourceAsPending: () => Result<{
        pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;
        diagnostics: string[];
    }>;
    // (undocumented)
    saveResourceEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => Result<void>;
    // (undocumented)
    selectResource: (resourceId: string | null) => void;
    // (undocumented)
    selectResourceForResolution: (resourceId: string) => Result<void>;
    // (undocumented)
    selectResourceType: (type: string) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    setResolutionViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;
    // Warning: (ae-forgotten-export) The symbol "IStartNewResourceParams" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    startNewResource: (params?: IStartNewResourceParams) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    updateConfiguration: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    updateFilterState: (state: Partial<IFilterState>) => void;
    // (undocumented)
    updateNewResourceId: (id: string) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    updateNewResourceJson: (json: JsonValue) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    updateResolutionContext: (qualifierName: string, value: string | undefined) => Result<void>;
}

// @public
export interface IOrchestratorState {
    // (undocumented)
    configuration: Config.Model.ISystemConfiguration | null;
    // (undocumented)
    error: string | null;
    // (undocumented)
    filterResult: IFilterResult | null;
    // (undocumented)
    filterState: IFilterState;
    // (undocumented)
    isProcessing: boolean;
    // (undocumented)
    messages: IMessage[];
    // (undocumented)
    resolutionState: IResolutionState;
    // (undocumented)
    resourceEditorFactory?: IResourceEditorFactory;
    // (undocumented)
    resources: IExtendedProcessedResources | null;
    // (undocumented)
    selectedResourceId: string | null;
}

// @public
interface IPendingResource<T = unknown> {
    displayName?: string;
    id: string;
    resourceData?: T;
    resourceType?: string;
    type: 'new' | 'modified' | 'deleted';
}

// @public
interface IProcessedResources {
    compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;
    resolver: Runtime.ResourceResolver;
    resourceCount: number;
    summary: {
        totalResources: number;
        resourceIds: string[];
        errorCount: number;
        warnings: string[];
    };
    system: {
        resourceManager: Resources.ResourceManagerBuilder;
        qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
        qualifiers: Qualifiers.IReadOnlyQualifierCollector;
        resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
        importManager: Import.ImportManager;
        contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
    };
}

// @public
interface IQualifierControlOptions {
    className?: string;
    editable?: boolean;
    hostValue?: string | undefined;
    placeholder?: string;
    showHostValue?: boolean;
    visible?: boolean;
}

// @public
export interface IResolutionActions {
    applyContext: (hostManagedValues?: Record<string, string | undefined>) => Result<void>;
    applyPendingResources: () => Promise<Result<{
        appliedCount: number;
        existingResourceEditCount: number;
        pendingResourceEditCount: number;
        newResourceCount: number;
        deletionCount: number;
    }>>;
    cancelNewResource: () => void;
    clearEdits: () => Result<{
        clearedCount: number;
    }>;
    createPendingResource: (params: ICreatePendingResourceParams) => Result<void>;
    discardEdits: () => Result<{
        discardedCount: number;
    }>;
    discardPendingResources: () => void;
    getEditedValue: (resourceId: string) => JsonValue | undefined;
    hasEdit: (resourceId: string) => boolean;
    markResourceForDeletion: (resourceId: string) => void;
    removePendingResource: (resourceId: string) => Result<void>;
    resetCache: () => Result<void>;
    saveEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => Result<void>;
    saveNewResourceAsPending: () => Result<{
        pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;
        diagnostics: string[];
    }>;
    selectResource: (resourceId: string) => Result<void>;
    selectResourceType: (type: string) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    setViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;
    startNewResource: (params?: IStartNewResourceParams) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    updateContextValue: (qualifierName: string, value: string | undefined) => Result<void>;
    updateNewResourceId: (id: string) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    updateNewResourceJson: (json: JsonValue) => Result<{
        draft: IResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
}

// @public
interface IResolutionContextOptions {
    contextPanelClassName?: string;
    contextPanelTitle?: string;
    defaultQualifierEditable?: boolean;
    // (undocumented)
    defaultQualifierVisible?: boolean;
    globalPlaceholder?: string | ((qualifierName: string) => string);
    hostManagedValues?: Record<string, string | undefined>;
    qualifierOptions?: Record<string, IQualifierControlOptions>;
    showContextActions?: boolean;
    showContextControls?: boolean;
    showCurrentContext?: boolean;
}

// @public
interface IResolutionContextOptionsControlProps {
    allowResourceCreation?: boolean;
    availableQualifiers?: string[];
    className?: string;
    onAllowResourceCreationChange?: (allow: boolean) => void;
    onOptionsChange: (options: IResolutionContextOptions) => void;
    onShowPendingResourcesInListChange?: (show: boolean) => void;
    options: IResolutionContextOptions;
    presentation?: 'hidden' | 'inline' | 'collapsible' | 'popup' | 'popover';
    showPendingResourcesInList?: boolean;
    title?: string;
}

// @public
interface IResolutionOptions {
    enableCaching?: boolean;
    enableDebugLogging?: boolean;
}

// @public
interface IResolutionResult<T = unknown, TV extends JsonCompatible<T> = JsonCompatible<T>> {
    allCandidates?: readonly Runtime.IResourceCandidate[];
    bestCandidate?: Runtime.IResourceCandidate;
    candidateDetails?: ICandidateInfo[];
    composedValue?: TV;
    error?: string;
    resource?: Runtime.IResource;
    resourceId: string;
    success: boolean;
}

// @public
interface IResolutionState {
    availableResourceTypes: ResourceTypes.IResourceType[];
    contextValues: Record<string, string | undefined>;
    currentResolver: Runtime.ResourceResolver | null;
    editedResources: Map<string, JsonValue>;
    hasPendingChanges: boolean;
    hasPendingResourceChanges: boolean;
    hasUnsavedEdits: boolean;
    isApplyingEdits: boolean;
    newResourceDraft?: {
        resourceId: string;
        resourceType: string;
        template: ResourceJson.Json.ILooseResourceDecl;
        isValid: boolean;
    };
    pendingContextValues: Record<string, string | undefined>;
    pendingResourceDeletions: Set<string>;
    pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;
    resolutionResult: IResolutionResult | null;
    selectedResourceId: string | null;
    viewMode: 'composed' | 'best' | 'all' | 'raw';
}

// @public
interface IResolutionViewProps extends IViewBaseProps {
    allowResourceCreation?: boolean;
    availableQualifiers?: string[];
    contextOptions?: IResolutionContextOptions;
    defaultResourceType?: string;
    filterResult?: IFilterResult | null;
    filterState?: IFilterState;
    lockedViewMode?: 'composed' | 'best' | 'all' | 'raw';
    onPendingResourcesApplied?: (added: ResourceJson.Json.ILooseResourceDecl[], deleted: string[]) => void;
    pickerOptions?: IResourcePickerOptions;
    resolutionActions?: IResolutionActions;
    resolutionState?: IResolutionState;
    resourceEditorFactory?: IResourceEditorFactory;
    resources?: IProcessedResources | null;
    resourceTypeFactory?: ResourceTypes.IResourceType[];
    sectionTitles?: {
        resources?: string;
        results?: string;
    };
    showPendingResourcesInList?: boolean;
}

// @public
interface IResourceAnnotation {
    badge?: {
        text: string;
        variant: 'info' | 'warning' | 'success' | 'error' | 'edited' | 'new';
    };
    className?: string;
    indicator?: {
        type: 'dot' | 'icon' | 'text';
        value: string | React_2.ReactNode;
        tooltip?: string;
    };
    suffix?: React_2.ReactNode;
}

// @public
interface IResourceAnnotations {
    [resourceId: string]: IResourceAnnotation;
}

// @public
interface IResourceDetailData {
    candidateCount: number;
    candidates: Array<ResourceJson.Normalized.IChildResourceCandidateDecl>;
    id: string;
    resourceType: string;
}

// @public
interface IResourceEditorFactory<T = unknown, TV extends JsonCompatible<T> = JsonCompatible<T>> {
    createEditor(resourceId: string, resourceType: string, value: TV): ResourceEditorResult<T, TV>;
}

// @public
interface IResourceEditorProps<T = unknown, TV extends JsonCompatible<T> = JsonCompatible<T>> {
    className?: string;
    disabled?: boolean;
    editedValue?: TV;
    isEdited?: boolean;
    onCancel?: (resourceId: string) => void;
    onSave?: (resourceId: string, editedValue: TV, originalValue: TV) => void;
    resourceId: string;
    value: TV;
}

// @public
interface IResourceManagerState {
    activeConfiguration: Config.Model.ISystemConfiguration | null;
    bundleMetadata: Bundle.IBundleMetadata | null;
    error: string | null;
    hasProcessedData: boolean;
    isLoadedFromBundle: boolean;
    isProcessing: boolean;
    processedResources: IExtendedProcessedResources | null;
}

// @public
interface IResourcePickerOptions {
    defaultView?: 'list' | 'tree';
    emptyMessage?: string;
    enableSearch?: boolean;
    height?: string | number;
    hideRootNode?: boolean;
    rootPath?: string;
    searchPlaceholder?: string;
    searchScope?: 'all' | 'current-branch';
    showViewToggle?: boolean;
}

// @public
interface IResourcePickerOptionsControlProps {
    className?: string;
    onOptionsChange: (options: IResourcePickerOptions) => void;
    options: IResourcePickerOptions;
    presentation?: 'hidden' | 'inline' | 'collapsible' | 'popup' | 'popover';
    quickBranchPaths?: string[];
    showAdvanced?: boolean;
    title?: string;
}

// @public
interface IResourcePickerProps<T = unknown> extends IViewBaseProps {
    onResourceSelect: (selection: IResourceSelection<T>) => void;
    options?: IResourcePickerOptions;
    pendingResources?: IPendingResource<T>[];
    resourceAnnotations?: IResourceAnnotations;
    resources: IProcessedResources | IExtendedProcessedResources | null;
    selectedResourceId: string | null;
}

// @public
interface IResourceSelection<T = unknown> {
    isPending?: boolean;
    pendingType?: 'new' | 'modified' | 'deleted';
    resourceData?: T;
    resourceId: string | null;
}

// @public
interface IResourceTypeColumnMapping {
    columns: IGridColumnDefinition[];
    defaultColumn?: IGridColumnDefinition;
    resourceType: string;
}

// @public
function isConsoleOnlyContext(context: IObservabilityContext): boolean;

// @public
interface ISourceViewProps extends IViewBaseProps {
    filterResult?: IFilterResult | null;
    filterState?: IFilterState;
    onExport?: (data: unknown, type: 'json') => void;
    onResourceSelect?: (resourceId: string) => void;
    pickerOptions?: IResourcePickerOptions;
    resources?: IExtendedProcessedResources | null;
    selectedResourceId?: string | null;
}

// @public
function isPendingAddition(resourceId: string, pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): boolean;

// @public
function isViewStateConnected(context: IObservabilityContext): boolean;

// @public
function isZipFile(filename: string): boolean;

// @public
interface IUserLogger extends Logging.ILogger {
    success(message?: unknown, ...parameters: unknown[]): Success<string | undefined>;
}

// @public
interface IViewBaseProps {
    className?: string;
    pickerOptionsPanelPresentation?: 'hidden' | 'inline' | 'collapsible' | 'popup' | 'popover';
}

export { JsonValue }

// @public
export const MessagesWindow: React_2.FC<IMessagesWindowProps>;

// @public
export const MultiGridView: React_2.FC<IMultiGridViewProps>;

// @public
class NoOpUserLogger extends Logging.LoggerBase implements IUserLogger {
    constructor(logLevel?: Logging.ReporterLogLevel);
    protected _log(message: string, __level: MessageLogLevel): Success<string | undefined>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    success(message?: unknown, ...parameters: unknown[]): Success<string | undefined>;
}

// @public
class ObservabilityContext implements IObservabilityContext {
    constructor(diag: Logging.ILogger, user: IUserLogger);
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    readonly diag: Logging.ILogger;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    readonly user: IUserLogger;
}

// @public
type ObservabilityContextType = 'viewstate' | 'console' | 'custom';

// @public
export const ObservabilityProvider: React_2.FC<IObservabilityProviderProps>;

declare namespace ObservabilityTools {
    export {
        IUserLogger,
        IObservabilityContext,
        ObservabilityContextType,
        ConsoleUserLogger,
        NoOpUserLogger,
        ViewStateUserLogger,
        ObservabilityContext,
        createConsoleObservabilityContext,
        createNoOpObservabilityContext,
        createViewStateObservabilityContext,
        DefaultObservabilityContext,
        TestObservabilityContext,
        detectObservabilityContextType,
        isViewStateConnected,
        isConsoleOnlyContext
    }
}
export { ObservabilityTools }

declare namespace PickerTools {
    export {
        ResourcePicker,
        ResourcePickerOptionsControl,
        IResourcePickerProps,
        IResourcePickerOptions,
        IResourceSelection,
        IResourceAnnotations,
        IResourceAnnotation,
        IPendingResource,
        IResourcePickerOptionsControlProps
    }
}
export { PickerTools }

// Warning: (ae-forgotten-export) The symbol "ICreateProcessImportedDirectoryParams" needs to be exported by the entry point index.d.ts
//
// @internal (undocumented)
function processImportedDirectory(params: ICreateProcessImportedDirectoryParams): Result<IExtendedProcessedResources>;

// Warning: (ae-forgotten-export) The symbol "ICreateProcessImportedFilesParams" needs to be exported by the entry point index.d.ts
//
// @internal (undocumented)
function processImportedFiles(params: ICreateProcessImportedFilesParams): Result<IExtendedProcessedResources>;

// @public
function processZipLoadResult(zipResult: {
    files: IImportedFile[];
    directory?: IImportedDirectory;
    config?: Config.Model.ISystemConfiguration;
}, overrideConfig?: Config.Model.ISystemConfiguration, o11y?: ObservabilityTools_2.IObservabilityContext): Promise<Result<IProcessedResources>>;

// @public
function processZipResources(files: IImportedFile[], directory: IImportedDirectory | undefined, config?: Config.Model.ISystemConfiguration, o11y?: ObservabilityTools_2.IObservabilityContext): Promise<Result<IProcessedResources>>;

// Warning: (ae-forgotten-export) The symbol "IQualifierContextControlProps" needs to be exported by the entry point index.d.ts
//
// @public
const QualifierContextControl: React_2.FC<IQualifierContextControlProps>;

// Warning: (ae-forgotten-export) The symbol "IQualifierEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public
const QualifierEditForm: React_2.FC<IQualifierEditFormProps>;

// Warning: (ae-forgotten-export) The symbol "IQualifierTypeEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public
const QualifierTypeEditForm: React_2.FC<IQualifierTypeEditFormProps>;

// @internal (undocumented)
function readFilesFromInput(files: FileList): Promise<IImportedFile[]>;

// @public
const ResolutionContextOptionsControl: React_2.FC<IResolutionContextOptionsControlProps>;

// Warning: (ae-forgotten-export) The symbol "IResolutionResultsProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResolutionResults: React_2.FC<IResolutionResultsProps>;

declare namespace ResolutionTools {
    export {
        ResolutionView,
        EditableJsonView,
        UnifiedChangeControls,
        QualifierContextControl,
        ResolutionContextOptionsControl,
        useResolutionState,
        createResolverWithContext,
        evaluateConditionsForCandidate,
        resolveResourceDetailed,
        getAvailableQualifiers,
        hasPendingContextChanges,
        IResolutionOptions,
        getPendingAdditionsByType,
        isPendingAddition,
        deriveLeafId,
        deriveFullId,
        getPendingResourceTypes,
        getPendingResourceStats,
        validatePendingResourceKeys,
        IResolutionState,
        IResolutionActions,
        IResolutionViewProps,
        IResolutionResult,
        ICandidateInfo,
        IConditionEvaluationResult,
        IEditedResourceInfo,
        IResolutionContextOptions,
        IQualifierControlOptions,
        ICreatePendingResourceParams,
        IEditableJsonViewProps,
        IResolutionContextOptionsControlProps
    }
}
export { ResolutionTools }

// @public
export const ResolutionView: React_2.FC<IResolutionViewProps>;

// @public
function resolveResourceDetailed(resolver: Runtime.ResourceResolver, resourceId: string, processedResources: IProcessedResources, options?: IResolutionOptions): Result<IResolutionResult>;

// @public
type ResourceEditorResult<T = unknown, TV extends JsonCompatible<T> = JsonCompatible<T>> = {
    success: true;
    editor: React.ComponentType<IResourceEditorProps<T, TV>>;
} | {
    success: false;
    message?: string;
};

// Warning: (ae-forgotten-export) The symbol "IResourceGridProps" needs to be exported by the entry point index.d.ts
//
// @public
const ResourceGrid: React_2.FC<IResourceGridProps>;

// Warning: (ae-forgotten-export) The symbol "IResourceListViewProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResourceListView: React_2.FC<IResourceListViewProps>;

// Warning: (ae-forgotten-export) The symbol "IResourceOrchestratorProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResourceOrchestrator: React_2.FC<IResourceOrchestratorProps>;

// @public
const ResourcePicker: <T = unknown>({ resources, selectedResourceId, onResourceSelect, resourceAnnotations, pendingResources, options, className }: IResourcePickerProps<T>) => ReactElement;

// @public
const ResourcePickerOptionsControl: React_2.FC<IResourcePickerOptionsControlProps>;

// @public
class ResourceSelector {
    constructor();
    getRegisteredTypes(): string[];
    // Warning: (ae-forgotten-export) The symbol "SelectorHandler" needs to be exported by the entry point index.d.ts
    registerSelector(type: string, handler: SelectorHandler): void;
    select(selector: GridResourceSelector, resources: IProcessedResources): Result<string[]>;
}

declare namespace ResourceTools {
    export {
        useResourceData,
        IProcessedResources,
        IExtendedProcessedResources,
        IResourceManagerState,
        IResourceEditorFactory,
        ResourceEditorResult,
        IResourceEditorProps,
        IResourceDetailData
    }
}
export { ResourceTools }

// Warning: (ae-forgotten-export) The symbol "IResourceTreeViewProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResourceTreeView: React_2.FC<IResourceTreeViewProps>;

// Warning: (ae-forgotten-export) The symbol "IResourceTypeEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public
const ResourceTypeEditForm: React_2.FC<IResourceTypeEditFormProps>;

export { Result }

// @public
function selectResources(selector: GridResourceSelector, resources: IProcessedResources): Result<string[]>;

// Warning: (ae-forgotten-export) The symbol "ISharedContextControlsProps" needs to be exported by the entry point index.d.ts
//
// @public
const SharedContextControls: React_2.FC<ISharedContextControlsProps>;

// Warning: (ae-forgotten-export) The symbol "ISourceResourceDetailProps" needs to be exported by the entry point index.d.ts
//
// @public
export const SourceResourceDetail: React_2.FC<ISourceResourceDetailProps>;

// @public
export const SourceView: React_2.FC<ISourceViewProps>;

// Warning: (ae-forgotten-export) The symbol "IStringCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const StringCell: React_2.FC<IStringCellProps>;

// @public
const TestObservabilityContext: IObservabilityContext;

// Warning: (ae-forgotten-export) The symbol "ITriStateCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const TriStateCell: React_2.FC<ITriStateCellProps>;

declare namespace TsResTools {
    export {
        SourceView,
        CompiledView,
        getDefaultSystemConfiguration,
        createSimpleContext,
        convertImportedDirectoryToFileTree,
        createTsResSystemFromConfig,
        processImportedFiles,
        processImportedDirectory,
        ISourceViewProps,
        ICompiledViewProps
    }
}
export { TsResTools }

// Warning: (ae-forgotten-export) The symbol "IUnifiedChangeControlsProps" needs to be exported by the entry point index.d.ts
//
// @public
const UnifiedChangeControls: React_2.FC<IUnifiedChangeControlsProps>;

// Warning: (ae-forgotten-export) The symbol "IUseFilterStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useFilterState(initialState?: Partial<IFilterState>): IUseFilterStateReturn;

// Warning: (ae-forgotten-export) The symbol "IUseIConfigurationStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useIConfigurationState(initialConfiguration?: Config.Model.ISystemConfiguration, onConfigurationChange?: (config: Config.Model.ISystemConfiguration) => void, onUnsavedChanges?: (hasChanges: boolean) => void): IUseIConfigurationStateReturn;

// @public
export const useObservability: () => ObservabilityTools_2.IObservabilityContext;

// Warning: (ae-forgotten-export) The symbol "IUseResolutionStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useResolutionState(processedResources: IProcessedResources | null, onSystemUpdate?: (updatedResources: IProcessedResources) => void): IUseResolutionStateReturn;

// Warning: (ae-forgotten-export) The symbol "IUseResourceDataParams" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IUseResourceDataReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useResourceData(params?: IUseResourceDataParams): IUseResourceDataReturn;

// @public
export function useSmartObservability(): IObservabilityContext;

// Warning: (ae-forgotten-export) The symbol "IUseViewStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useViewState(): IUseViewStateReturn;

// Warning: (ae-forgotten-export) The symbol "ICellValidationResult" needs to be exported by the entry point index.d.ts
//
// @public
function validateCellValue(value: JsonValue, validation?: IGridCellValidation): Result<ICellValidationResult>;

// Warning: (ae-forgotten-export) The symbol "IConfigurationValidationResult" needs to be exported by the entry point index.d.ts
//
// @public
function validateConfiguration(config: Config.Model.ISystemConfiguration): IConfigurationValidationResult;

// @public
function validatePendingResourceKeys(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): Result<void>;

// @public
const ValidationFunctions: {
    validJson: (value: JsonValue) => string | null;
    numberRange: (min: number, max: number) => (value: JsonValue) => string | null;
    oneOf: (allowedValues: JsonValue[]) => (value: JsonValue) => string | null;
    excludeCharacters: (forbiddenChars: string) => (value: JsonValue) => string | null;
};

// @public
const ValidationPatterns: Record<string, RegExp>;

declare namespace ViewStateTools {
    export {
        MessagesWindow,
        useViewState,
        IMessage_2 as IMessage,
        IMessagesWindowProps,
        IViewBaseProps
    }
}
export { ViewStateTools }

// @public
class ViewStateUserLogger extends Logging.LoggerBase implements IUserLogger {
    constructor(addMessage: (type: IMessage['type'], message: string) => void, logLevel?: Logging.ReporterLogLevel);
    protected _log(message: string, level: MessageLogLevel): Success<string | undefined>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    success(message?: unknown, ...parameters: unknown[]): Success<string | undefined>;
}

declare namespace ZipTools {
    export {
        ImportView,
        isZipFile,
        processZipResources,
        processZipLoadResult,
        IImportViewProps
    }
}
export { ZipTools }

// (No @packageDocumentation comment for this package)

```
