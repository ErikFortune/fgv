## API Report File for "@fgv/ts-res-ui-components"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Bundle } from '@fgv/ts-res';
import { Config } from '@fgv/ts-res';
import { FileTree } from '@fgv/ts-utils';
import { Import } from '@fgv/ts-res';
import { JsonValue } from '@fgv/ts-json-base';
import { Qualifiers } from '@fgv/ts-res';
import { QualifierTypes } from '@fgv/ts-res';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { ResourceJson } from '@fgv/ts-res';
import { Resources } from '@fgv/ts-res';
import { ResourceTypes } from '@fgv/ts-res';
import { Result } from '@fgv/ts-utils';
import { Runtime } from '@fgv/ts-res';

// @public
function analyzeFilteredResources(originalResourceIds: string[], filteredProcessedResources: ProcessedResources, originalProcessedResources: ProcessedResources): FilterResult;

// Warning: (ae-forgotten-export) The symbol "BooleanCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const BooleanCell: React_2.FC<BooleanCellProps>;

// @public
interface CandidateInfo {
    candidate: Runtime.IResourceCandidate;
    candidateIndex: number;
    conditionEvaluations?: ConditionEvaluationResult[];
    conditionSetKey: string | null;
    isDefaultMatch: boolean;
    matched: boolean;
    matchType: 'match' | 'matchAsDefault' | 'noMatch';
}

// @public
const clearAllGridValidationErrors: () => void;

// @public
function cloneConfiguration(config: Config.Model.ISystemConfiguration): Config.Model.ISystemConfiguration;

// @public
export const CompiledView: React_2.FC<CompiledViewProps>;

// @public
interface CompiledViewProps extends ViewBaseProps {
    filterResult?: FilterResult | null;
    filterState?: FilterState;
    onExport?: (data: ResourceJson.Compiled.ICompiledResourceCollection | Bundle.IBundle, type: 'json' | 'bundle') => void;
    pickerOptions?: ResourcePickerOptions;
    resources?: ExtendedProcessedResources | null;
    useNormalization?: boolean;
}

// @public
interface ConditionEvaluationResult {
    conditionIndex: number;
    conditionValue: string | undefined;
    matched: boolean;
    matchType: 'match' | 'matchAsDefault' | 'noMatch';
    operator: string;
    qualifierName: string;
    qualifierValue: string | undefined;
    score: number;
    scoreAsDefault?: number;
}

declare namespace ConfigurationTools {
    export {
        ConfigurationView,
        QualifierTypeEditForm,
        QualifierEditForm,
        ResourceTypeEditForm,
        HierarchyEditor,
        useConfigurationState,
        getDefaultConfiguration,
        validateConfiguration,
        cloneConfiguration,
        exportConfiguration,
        importConfiguration,
        ConfigurationViewProps
    }
}

// @public
export const ConfigurationView: React_2.FC<ConfigurationViewProps>;

// @public
interface ConfigurationViewProps extends ViewBaseProps {
    configuration?: Config.Model.ISystemConfiguration | null;
    hasUnsavedChanges?: boolean;
    onConfigurationChange?: (config: Config.Model.ISystemConfiguration) => void;
    onSave?: (config: Config.Model.ISystemConfiguration) => void;
}

// @internal (undocumented)
function convertImportedDirectoryToFileTree(directory: ImportedDirectory): FileTree.FileTree;

// @public
const createFilteredResourceManagerSimple: (originalSystem: ProcessedResources["system"], partialContext: Record<string, string | undefined>, options?: FilterOptions) => Promise<Result<ProcessedResources>>;

// @public
interface CreatePendingResourceParams {
    id: string;
    json?: JsonValue;
    resourceTypeName: string;
}

// @public
function createResolverWithContext(processedResources: ProcessedResources, contextValues: Record<string, string | undefined>, options?: ResolutionOptions): Result<Runtime.ResourceResolver>;

// @internal (undocumented)
function createSimpleContext(qualifiers: Qualifiers.IReadOnlyQualifierCollector, values: Record<string, string | undefined>): Result<Runtime.ValidatingSimpleContextQualifierProvider>;

// @internal (undocumented)
function createTsResSystemFromConfig(systemConfig?: Config.Model.ISystemConfiguration, qualifierTypeFactory?: Config.IConfigInitFactory<QualifierTypes.Config.IAnyQualifierTypeConfig, QualifierTypes.QualifierType>, resourceTypeFactory?: Config.IConfigInitFactory<ResourceTypes.Config.IResourceTypeConfig, ResourceTypes.ResourceType>): Result<{
    qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
    qualifiers: Qualifiers.IReadOnlyQualifierCollector;
    resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
    resourceManager: Resources.ResourceManagerBuilder;
    importManager: Import.ImportManager;
    contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
}>;

// @public
interface CustomResourceSelector {
    displayName?: string;
    id: string;
    select: (resources: ProcessedResources) => string[];
}

// @public
const defaultResourceSelector: ResourceSelector;

// @public
function deriveFullId(rootPath: string, leafId: string): Result<string>;

// @public
function deriveLeafId(fullResourceId: string): Result<string>;

// Warning: (ae-forgotten-export) The symbol "DropdownCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const DropdownCell: React_2.FC<DropdownCellProps>;

// Warning: (ae-forgotten-export) The symbol "EditableGridCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const EditableGridCell: React_2.FC<EditableGridCellProps>;

// @public
const EditableJsonView: React_2.FC<EditableJsonViewProps>;

// @public
interface EditableJsonViewProps {
    className?: string;
    disabled?: boolean;
    editedValue?: any;
    isEdited?: boolean;
    onCancel?: (resourceId: string) => void;
    onSave?: (resourceId: string, editedValue: any, originalValue: any) => void;
    resourceId: string;
    value: any;
}

// @public
interface EditedResourceInfo {
    // (undocumented)
    editedValue: JsonValue;
    // (undocumented)
    originalValue: JsonValue;
    resourceId: string;
    // (undocumented)
    timestamp: Date;
}

// @public
function evaluateConditionsForCandidate(resolver: Runtime.ResourceResolver, candidateIndex: number, compiledResource: any, compiledCollection: any): ConditionEvaluationResult[];

// @internal (undocumented)
function exportAsJson(data: any, filename: string): void;

// Warning: (ae-forgotten-export) The symbol "ConfigurationExportOptions" needs to be exported by the entry point index.d.ts
//
// @public
function exportConfiguration(config: Config.Model.ISystemConfiguration, options?: ConfigurationExportOptions): Result<string>;

// @internal (undocumented)
function exportUsingFileSystemAPI(data: any, suggestedName: string, description?: string): Promise<boolean>;

// @public
interface ExtendedProcessedResources extends ProcessedResources {
    activeConfiguration?: Config.Model.ISystemConfiguration | null;
    bundleMetadata?: Bundle.IBundleMetadata | null;
    isLoadedFromBundle?: boolean;
}

// @internal (undocumented)
function filesToDirectory(files: ImportedFile[]): ImportedDirectory;

// @public
interface FilterActions {
    applyFilterValues: () => void;
    resetFilterValues: () => void;
    updateFilterEnabled: (enabled: boolean) => void;
    updateFilterValues: (values: Record<string, string | undefined>) => void;
    updateReduceQualifiers: (reduceQualifiers: boolean) => void;
}

// @public
interface FilteredResource {
    filteredCandidateCount: number;
    hasWarning: boolean;
    id: string;
    originalCandidateCount: number;
}

// @public
interface FilterOptions {
    enableDebugLogging?: boolean;
    partialContextMatch?: boolean;
    reduceQualifiers?: boolean;
}

// @public
interface FilterResult {
    error?: string;
    filteredResources: FilteredResource[];
    processedResources?: ProcessedResources;
    success: boolean;
    warnings: string[];
}

// @public
interface FilterState {
    appliedValues: Record<string, string | undefined>;
    enabled: boolean;
    hasPendingChanges: boolean;
    reduceQualifiers: boolean;
    values: Record<string, string | undefined>;
}

declare namespace FilterTools {
    export {
        FilterView,
        useFilterState,
        createFilteredResourceManagerSimple,
        analyzeFilteredResources,
        hasFilterValues,
        getFilterSummary,
        FilterOptions,
        FilterState,
        FilterActions,
        FilterViewProps,
        FilterResult,
        FilteredResource
    }
}

// @public
export const FilterView: React_2.FC<FilterViewProps>;

// @public
interface FilterViewProps extends ViewBaseProps {
    contextOptions?: ResolutionContextOptions;
    filterActions: FilterActions;
    filterResult?: FilterResult | null;
    filterState: FilterState;
    onFilterResult?: (result: FilterResult | null) => void;
    pickerOptions?: ResourcePickerOptions;
    resources?: ProcessedResources | null;
}

// @public
const getAllGridValidationErrors: () => {
    resourceId: string;
    columnId: string;
    error: string;
}[];

// @public
function getAvailableQualifiers(processedResources: ProcessedResources): string[];

// @public
function getDefaultConfiguration(): Config.Model.ISystemConfiguration;

// @internal (undocumented)
function getDefaultSystemConfiguration(): Config.Model.ISystemConfiguration;

// @public
function getFilterSummary(values: Record<string, string | undefined>): string;

// @public
function getPendingAdditionsByType(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>, resourceType: string): Array<{
    id: string;
    resource: ResourceJson.Json.ILooseResourceDecl;
}>;

// @public
function getPendingResourceStats(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): {
    totalCount: number;
    byType: Record<string, number>;
    resourceIds: string[];
};

// @public
function getPendingResourceTypes(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): string[];

// @public
interface GridCellEditorProps extends GridCellProps {
    disabled?: boolean;
    editedValue?: JsonValue;
    onCancel: () => void;
    onSave: (resourceId: string, newValue: JsonValue, originalValue: JsonValue) => void;
}

// @public
interface GridCellProps {
    className?: string;
    column: GridColumnDefinition;
    isEdited: boolean;
    resolvedValue: JsonValue;
    resourceId: string;
    value: JsonValue;
}

// @public
interface GridCellValidation {
    custom?: (value: JsonValue) => string | null;
    maxLength?: number;
    minLength?: number;
    pattern?: RegExp;
    required?: boolean;
}

// @public
interface GridColumnDefinition {
    allowCustomValue?: boolean;
    cellEditor?: React.ComponentType<GridCellEditorProps>;
    cellRenderer?: React.ComponentType<GridCellProps>;
    cellType?: 'string' | 'boolean' | 'tristate' | 'dropdown' | 'custom';
    dataPath: string | string[];
    dropdownOptions?: GridDropdownOption[] | (() => Promise<GridDropdownOption[]>);
    editable?: boolean;
    id: string;
    sortable?: boolean;
    title: string;
    triStateLabels?: {
        trueLabel: string;
        falseLabel: string;
        undefinedLabel: string;
    };
    triStatePresentation?: 'checkbox' | 'dropdown';
    validation?: GridCellValidation;
    width?: number;
}

// @public
interface GridDropdownOption {
    disabled?: boolean;
    label: string;
    value: string;
}

// @public
interface GridPresentationOptions {
    className?: string;
    enableFiltering?: boolean;
    enableSorting?: boolean;
    pageSize?: number;
    showRowNumbers?: boolean;
    showSummaryRow?: boolean;
}

// @public
type GridResourceSelector = {
    type: 'ids';
    resourceIds: string[];
} | {
    type: 'prefix';
    prefix: string;
} | {
    type: 'suffix';
    suffix: string;
} | {
    type: 'resourceTypes';
    types: string[];
} | {
    type: 'pattern';
    pattern: string;
} | {
    type: 'all';
} | {
    type: 'custom';
    selector: CustomResourceSelector;
};

// Warning: (ae-forgotten-export) The symbol "GridSelectorProps" needs to be exported by the entry point index.d.ts
//
// @public
const GridSelector: React_2.FC<GridSelectorProps>;

declare namespace GridTools {
    export {
        GridView,
        MultiGridView,
        ResourceGrid,
        EditableGridCell,
        SharedContextControls,
        GridSelector,
        StringCell,
        BooleanCell,
        TriStateCell,
        DropdownCell,
        ResourceSelector,
        defaultResourceSelector,
        selectResources,
        validateCellValue,
        ValidationPatterns,
        ValidationFunctions,
        GridValidationState,
        hasGridValidationErrors,
        getAllGridValidationErrors,
        clearAllGridValidationErrors,
        GridViewProps,
        MultiGridViewProps,
        GridViewInitParams,
        GridColumnDefinition,
        GridDropdownOption,
        GridCellValidation,
        GridResourceSelector,
        CustomResourceSelector,
        GridPresentationOptions,
        ResourceTypeColumnMapping,
        GridCellProps,
        GridCellEditorProps
    }
}

// @public
class GridValidationState {
    clearAll(): void;
    clearCell(resourceId: string, columnId: string): void;
    clearResource(resourceId: string): void;
    get errorCount(): number;
    getAllErrors(): Array<{
        resourceId: string;
        columnId: string;
        error: string;
    }>;
    getCellError(resourceId: string, columnId: string): string | null;
    getResourceErrors(resourceId: string): Map<string, string>;
    hasCellError(resourceId: string, columnId: string): boolean;
    get hasErrors(): boolean;
    setCellError(resourceId: string, columnId: string, error: string | null): void;
}

// @public
export const GridView: React_2.FC<GridViewProps>;

// @public
interface GridViewInitParams {
    columnMapping: ResourceTypeColumnMapping[];
    description?: string;
    id: string;
    presentationOptions?: GridPresentationOptions;
    resourceSelection: GridResourceSelector;
    title: string;
}

// @public
interface GridViewProps extends ViewBaseProps {
    availableQualifiers?: string[];
    contextOptions?: ResolutionContextOptions;
    filterResult?: FilterResult | null;
    filterState?: FilterState;
    gridConfig: GridViewInitParams;
    resolutionActions?: ResolutionActions;
    resolutionState?: ResolutionState;
    resources?: ProcessedResources | null;
    showChangeControls?: boolean;
    showContextControls?: boolean;
}

// @public
function hasFilterValues(values: Record<string, string | undefined>): boolean;

// @public
const hasGridValidationErrors: () => boolean;

// @public
function hasPendingContextChanges(contextValues: Record<string, string | undefined>, pendingContextValues: Record<string, string | undefined>): boolean;

// Warning: (ae-forgotten-export) The symbol "HierarchyEditorProps" needs to be exported by the entry point index.d.ts
//
// @public
const HierarchyEditor: React_2.FC<HierarchyEditorProps>;

// @public
function importConfiguration(data: string): Result<Config.Model.ISystemConfiguration>;

// @public
interface ImportedDirectory {
    files: ImportedFile[];
    name: string;
    path?: string;
    subdirectories?: ImportedDirectory[];
}

// @public
interface ImportedFile {
    content: string;
    name: string;
    path?: string;
    type?: string;
}

declare namespace ImportTools {
    export {
        ImportView,
        readFilesFromInput,
        filesToDirectory,
        exportAsJson,
        exportUsingFileSystemAPI,
        ImportedFile,
        ImportedDirectory,
        ImportViewProps
    }
}

// @public
export const ImportView: React_2.FC<ImportViewProps>;

// @public
interface ImportViewProps extends ViewBaseProps {
    acceptedFileTypes?: string[];
    onBundleImport?: (bundle: Bundle.IBundle) => void;
    onImport?: (data: ImportedDirectory | ImportedFile[]) => void;
    onZipImport?: (zipData: ImportedDirectory | ImportedFile[], config?: Config.Model.ISystemConfiguration) => void;
}

// @public
function isPendingAddition(resourceId: string, pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): boolean;

// @public
function isZipFile(filename: string): boolean;

export { JsonValue }

// @public
interface Message_2 {
    id: string;
    message: string;
    timestamp: Date;
    type: 'info' | 'warning' | 'error' | 'success';
}

// @public
export const MessagesWindow: React_2.FC<MessagesWindowProps>;

// @public
interface MessagesWindowProps {
    className?: string;
    messages: Message_2[];
    onClearMessages: () => void;
}

// @public
export const MultiGridView: React_2.FC<MultiGridViewProps>;

// @public
interface MultiGridViewProps extends ViewBaseProps {
    allowGridReordering?: boolean;
    availableQualifiers?: string[];
    contextOptions?: ResolutionContextOptions;
    defaultActiveGrid?: string;
    filterResult?: FilterResult | null;
    filterState?: FilterState;
    gridConfigurations: GridViewInitParams[];
    resolutionActions?: ResolutionActions;
    resolutionState?: ResolutionState;
    resources?: ProcessedResources | null;
    tabsPresentation?: 'tabs' | 'cards' | 'accordion' | 'dropdown';
}

// @public
export interface OrchestratorActions {
    // Warning: (ae-forgotten-export) The symbol "Message" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addMessage: (type: Message['type'], message: string) => void;
    // (undocumented)
    applyConfiguration: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    applyFilter: () => Promise<FilterResult | null>;
    // (undocumented)
    applyPendingResources: () => Promise<Result<{
        appliedCount: number;
        existingResourceEditCount: number;
        pendingResourceEditCount: number;
        newResourceCount: number;
        deletionCount: number;
    }>>;
    // (undocumented)
    applyResolutionContext: () => void;
    // (undocumented)
    cancelNewResource: () => void;
    // (undocumented)
    clearMessages: () => void;
    // (undocumented)
    clearResourceEdits: () => void;
    // (undocumented)
    clearResources: () => void;
    // (undocumented)
    createPendingResource: (params: CreatePendingResourceParams) => Result<void>;
    // (undocumented)
    discardPendingResources: () => void;
    // (undocumented)
    discardResourceEdits: () => void;
    // (undocumented)
    getEditedValue: (resourceId: string) => JsonValue | undefined;
    // (undocumented)
    hasResourceEdit: (resourceId: string) => boolean;
    // (undocumented)
    importBundle: (bundle: Bundle.IBundle) => Promise<void>;
    // (undocumented)
    importDirectory: (directory: ImportedDirectory) => Promise<void>;
    // (undocumented)
    importDirectoryWithConfig: (directory: ImportedDirectory, config: Config.Model.ISystemConfiguration) => Promise<void>;
    // (undocumented)
    importFiles: (files: ImportedFile[]) => Promise<void>;
    // (undocumented)
    markResourceForDeletion: (resourceId: string) => void;
    // (undocumented)
    removePendingResource: (resourceId: string) => void;
    // (undocumented)
    resetFilter: () => void;
    // (undocumented)
    resetResolutionCache: () => void;
    // (undocumented)
    resolveResource: (resourceId: string, context?: Record<string, string>) => Promise<Result<JsonValue>>;
    // (undocumented)
    saveNewResourceAsPending: () => Result<{
        pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;
        diagnostics: string[];
    }>;
    // (undocumented)
    saveResourceEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => void;
    // (undocumented)
    selectResource: (resourceId: string | null) => void;
    // (undocumented)
    selectResourceForResolution: (resourceId: string) => void;
    // (undocumented)
    selectResourceType: (type: string) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    setResolutionViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;
    // Warning: (ae-forgotten-export) The symbol "StartNewResourceParams" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    startNewResource: (params?: StartNewResourceParams) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    updateConfiguration: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    updateFilterState: (state: Partial<FilterState>) => void;
    // (undocumented)
    updateNewResourceId: (id: string) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    updateNewResourceJson: (json: JsonValue) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    // (undocumented)
    updateResolutionContext: (qualifierName: string, value: string | undefined) => void;
}

// @public
export interface OrchestratorState {
    // (undocumented)
    configuration: Config.Model.ISystemConfiguration | null;
    // (undocumented)
    error: string | null;
    // (undocumented)
    filterResult: FilterResult | null;
    // (undocumented)
    filterState: FilterState;
    // (undocumented)
    isProcessing: boolean;
    // (undocumented)
    messages: Message[];
    // (undocumented)
    resolutionState: ResolutionState;
    // (undocumented)
    resources: ExtendedProcessedResources | null;
    // (undocumented)
    selectedResourceId: string | null;
}

// @public
interface PendingResource<T = unknown> {
    displayName?: string;
    id: string;
    resourceData?: T;
    resourceType?: string;
    type: 'new' | 'modified' | 'deleted';
}

declare namespace PickerTools {
    export {
        ResourcePicker,
        ResourcePickerOptionsControl,
        ResourcePickerProps,
        ResourcePickerOptions,
        ResourceSelection,
        ResourceAnnotations,
        ResourceAnnotation,
        PendingResource,
        ResourcePickerOptionsControlProps
    }
}

// @public
interface ProcessedResources {
    compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;
    resolver: Runtime.ResourceResolver;
    resourceCount: number;
    summary: {
        totalResources: number;
        resourceIds: string[];
        errorCount: number;
        warnings: string[];
    };
    system: {
        resourceManager: Resources.ResourceManagerBuilder;
        qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
        qualifiers: Qualifiers.IReadOnlyQualifierCollector;
        resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
        importManager: Import.ImportManager;
        contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
    };
}

// @internal (undocumented)
function processImportedDirectory(directory: ImportedDirectory, systemConfig?: Config.Model.ISystemConfiguration, qualifierTypeFactory?: Config.IConfigInitFactory<QualifierTypes.Config.IAnyQualifierTypeConfig, QualifierTypes.QualifierType>, resourceTypeFactory?: Config.IConfigInitFactory<ResourceTypes.Config.IResourceTypeConfig, ResourceTypes.ResourceType>): Result<{
    system: {
        qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
        qualifiers: Qualifiers.IReadOnlyQualifierCollector;
        resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
        resourceManager: Resources.ResourceManagerBuilder;
        importManager: Import.ImportManager;
        contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
    };
    compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;
    resolver: Runtime.ResourceResolver;
    resourceCount: number;
    summary: {
        totalResources: number;
        resourceIds: string[];
        errorCount: number;
        warnings: string[];
    };
}>;

// @internal (undocumented)
function processImportedFiles(files: ImportedFile[], systemConfig?: Config.Model.ISystemConfiguration, qualifierTypeFactory?: Config.IConfigInitFactory<QualifierTypes.Config.IAnyQualifierTypeConfig, QualifierTypes.QualifierType>, resourceTypeFactory?: Config.IConfigInitFactory<ResourceTypes.Config.IResourceTypeConfig, ResourceTypes.ResourceType>): Result<{
    system: {
        qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
        qualifiers: Qualifiers.IReadOnlyQualifierCollector;
        resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
        resourceManager: Resources.ResourceManagerBuilder;
        importManager: Import.ImportManager;
        contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
    };
    compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;
    resolver: Runtime.ResourceResolver;
    resourceCount: number;
    summary: {
        totalResources: number;
        resourceIds: string[];
        errorCount: number;
        warnings: string[];
    };
}>;

// @public
function processZipLoadResult(zipResult: {
    files: ImportedFile[];
    directory?: ImportedDirectory;
    config?: Config.Model.ISystemConfiguration;
}, overrideConfig?: Config.Model.ISystemConfiguration): Promise<Result<ProcessedResources>>;

// @public
function processZipResources(files: ImportedFile[], directory: ImportedDirectory | undefined, config?: Config.Model.ISystemConfiguration): Promise<Result<ProcessedResources>>;

// Warning: (ae-forgotten-export) The symbol "QualifierContextControlProps" needs to be exported by the entry point index.d.ts
//
// @public
const QualifierContextControl: React_2.FC<QualifierContextControlProps>;

// @public
interface QualifierControlOptions {
    className?: string;
    editable?: boolean;
    hostValue?: string | undefined;
    placeholder?: string;
    showHostValue?: boolean;
    visible?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "QualifierEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public
const QualifierEditForm: React_2.FC<QualifierEditFormProps>;

// Warning: (ae-forgotten-export) The symbol "QualifierTypeEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public
const QualifierTypeEditForm: React_2.FC<QualifierTypeEditFormProps>;

// @internal (undocumented)
function readFilesFromInput(files: FileList): Promise<ImportedFile[]>;

// @public
interface ResolutionActions {
    applyContext: (hostManagedValues?: Record<string, string | undefined>) => Result<void>;
    applyPendingResources: () => Promise<Result<{
        appliedCount: number;
        existingResourceEditCount: number;
        pendingResourceEditCount: number;
        newResourceCount: number;
        deletionCount: number;
    }>>;
    cancelNewResource: () => void;
    clearEdits: () => Result<{
        clearedCount: number;
    }>;
    createPendingResource: (params: CreatePendingResourceParams) => Result<void>;
    discardEdits: () => Result<{
        discardedCount: number;
    }>;
    discardPendingResources: () => void;
    getEditedValue: (resourceId: string) => JsonValue | undefined;
    hasEdit: (resourceId: string) => boolean;
    markResourceForDeletion: (resourceId: string) => void;
    removePendingResource: (resourceId: string) => Result<void>;
    resetCache: () => Result<void>;
    saveEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => Result<void>;
    saveNewResourceAsPending: () => Result<{
        pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;
        diagnostics: string[];
    }>;
    selectResource: (resourceId: string) => Result<void>;
    selectResourceType: (type: string) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    setViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;
    startNewResource: (params?: StartNewResourceParams) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    updateContextValue: (qualifierName: string, value: string | undefined) => Result<void>;
    updateNewResourceId: (id: string) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
    updateNewResourceJson: (json: JsonValue) => Result<{
        draft: ResolutionState['newResourceDraft'];
        diagnostics: string[];
    }>;
}

// @public
interface ResolutionContextOptions {
    contextPanelClassName?: string;
    contextPanelTitle?: string;
    defaultQualifierEditable?: boolean;
    // (undocumented)
    defaultQualifierVisible?: boolean;
    globalPlaceholder?: string | ((qualifierName: string) => string);
    hostManagedValues?: Record<string, string | undefined>;
    qualifierOptions?: Record<string, QualifierControlOptions>;
    showContextActions?: boolean;
    showContextControls?: boolean;
    showCurrentContext?: boolean;
}

// @public
const ResolutionContextOptionsControl: React_2.FC<ResolutionContextOptionsControlProps>;

// @public
interface ResolutionContextOptionsControlProps {
    allowResourceCreation?: boolean;
    availableQualifiers?: string[];
    className?: string;
    onAllowResourceCreationChange?: (allow: boolean) => void;
    onOptionsChange: (options: ResolutionContextOptions) => void;
    onShowPendingResourcesInListChange?: (show: boolean) => void;
    options: ResolutionContextOptions;
    presentation?: 'hidden' | 'inline' | 'collapsible' | 'popup' | 'popover';
    showPendingResourcesInList?: boolean;
    title?: string;
}

// @public
interface ResolutionOptions {
    enableCaching?: boolean;
    enableDebugLogging?: boolean;
}

// @public
interface ResolutionResult {
    allCandidates?: readonly Runtime.IResourceCandidate[];
    bestCandidate?: Runtime.IResourceCandidate;
    candidateDetails?: CandidateInfo[];
    composedValue?: JsonValue;
    error?: string;
    resource?: Runtime.IResource;
    resourceId: string;
    success: boolean;
}

// Warning: (ae-forgotten-export) The symbol "ResolutionResultsProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResolutionResults: React_2.FC<ResolutionResultsProps>;

// @public
interface ResolutionState {
    availableResourceTypes: ResourceTypes.IResourceType[];
    contextValues: Record<string, string | undefined>;
    currentResolver: Runtime.ResourceResolver | null;
    editedResources: Map<string, JsonValue>;
    hasPendingChanges: boolean;
    hasPendingResourceChanges: boolean;
    hasUnsavedEdits: boolean;
    isApplyingEdits: boolean;
    newResourceDraft?: {
        resourceId: string;
        resourceType: string;
        template: ResourceJson.Json.ILooseResourceDecl;
        isValid: boolean;
    };
    pendingContextValues: Record<string, string | undefined>;
    pendingResourceDeletions: Set<string>;
    pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;
    resolutionResult: ResolutionResult | null;
    selectedResourceId: string | null;
    viewMode: 'composed' | 'best' | 'all' | 'raw';
}

declare namespace ResolutionTools {
    export {
        ResolutionView,
        EditableJsonView,
        UnifiedChangeControls,
        QualifierContextControl,
        ResolutionContextOptionsControl,
        useResolutionState,
        createResolverWithContext,
        evaluateConditionsForCandidate,
        resolveResourceDetailed,
        getAvailableQualifiers,
        hasPendingContextChanges,
        ResolutionOptions,
        getPendingAdditionsByType,
        isPendingAddition,
        deriveLeafId,
        deriveFullId,
        getPendingResourceTypes,
        getPendingResourceStats,
        validatePendingResourceKeys,
        ResolutionState,
        ResolutionActions,
        ResolutionViewProps,
        ResolutionResult,
        CandidateInfo,
        ConditionEvaluationResult,
        EditedResourceInfo,
        ResolutionContextOptions,
        QualifierControlOptions,
        CreatePendingResourceParams,
        EditableJsonViewProps,
        ResolutionContextOptionsControlProps
    }
}

// @public
export const ResolutionView: React_2.FC<ResolutionViewProps>;

// @public
interface ResolutionViewProps extends ViewBaseProps {
    allowResourceCreation?: boolean;
    availableQualifiers?: string[];
    contextOptions?: ResolutionContextOptions;
    defaultResourceType?: string;
    filterResult?: FilterResult | null;
    filterState?: FilterState;
    lockedViewMode?: 'composed' | 'best' | 'all' | 'raw';
    onPendingResourcesApplied?: (added: ResourceJson.Json.ILooseResourceDecl[], deleted: string[]) => void;
    pickerOptions?: ResourcePickerOptions;
    resolutionActions?: ResolutionActions;
    resolutionState?: ResolutionState;
    resourceEditorFactory?: ResourceEditorFactory;
    resources?: ProcessedResources | null;
    resourceTypeFactory?: ResourceTypes.IResourceType[];
    sectionTitles?: {
        resources?: string;
        results?: string;
    };
    showPendingResourcesInList?: boolean;
}

// @public
function resolveResourceDetailed(resolver: Runtime.ResourceResolver, resourceId: string, processedResources: ProcessedResources, options?: ResolutionOptions): Result<ResolutionResult>;

// @public
interface ResourceAnnotation {
    badge?: {
        text: string;
        variant: 'info' | 'warning' | 'success' | 'error' | 'edited' | 'new';
    };
    className?: string;
    indicator?: {
        type: 'dot' | 'icon' | 'text';
        value: string | React_2.ReactNode;
        tooltip?: string;
    };
    suffix?: React_2.ReactNode;
}

// @public
interface ResourceAnnotations {
    [resourceId: string]: ResourceAnnotation;
}

// @public
interface ResourceDetailData {
    candidateCount: number;
    candidates: Array<{
        json: JsonValue;
        conditions: Array<{
            qualifier: string;
            operator: string;
            value: string;
            priority: number;
            scoreAsDefault?: number;
        }>;
        isPartial: boolean;
        mergeMethod: string;
    }>;
    id: string;
    resourceType: string;
}

// @public
interface ResourceEditorFactory {
    createEditor(resourceId: string, resourceType: string, value: any): ResourceEditorResult;
}

// @public
interface ResourceEditorProps {
    className?: string;
    disabled?: boolean;
    editedValue?: any;
    isEdited?: boolean;
    onCancel?: (resourceId: string) => void;
    onSave?: (resourceId: string, editedValue: any, originalValue: any) => void;
    resourceId: string;
    value: any;
}

// @public
type ResourceEditorResult = {
    success: true;
    editor: React.ComponentType<ResourceEditorProps>;
} | {
    success: false;
    message?: string;
};

// Warning: (ae-forgotten-export) The symbol "ResourceGridProps" needs to be exported by the entry point index.d.ts
//
// @public
const ResourceGrid: React_2.FC<ResourceGridProps>;

// Warning: (ae-forgotten-export) The symbol "ResourceListViewProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResourceListView: React_2.FC<ResourceListViewProps>;

// @public
interface ResourceManagerState {
    activeConfiguration: Config.Model.ISystemConfiguration | null;
    bundleMetadata: Bundle.IBundleMetadata | null;
    error: string | null;
    hasProcessedData: boolean;
    isLoadedFromBundle: boolean;
    isProcessing: boolean;
    processedResources: ExtendedProcessedResources | null;
}

// Warning: (ae-forgotten-export) The symbol "ResourceOrchestratorProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResourceOrchestrator: React_2.FC<ResourceOrchestratorProps>;

// @public
const ResourcePicker: <T = unknown>({ resources, selectedResourceId, onResourceSelect, resourceAnnotations, pendingResources, options, className, onMessage }: ResourcePickerProps<T>) => React_2.JSX.Element;

// @public
interface ResourcePickerOptions {
    defaultView?: 'list' | 'tree';
    emptyMessage?: string;
    enableSearch?: boolean;
    height?: string | number;
    hideRootNode?: boolean;
    rootPath?: string;
    searchPlaceholder?: string;
    searchScope?: 'all' | 'current-branch';
    showViewToggle?: boolean;
}

// @public
const ResourcePickerOptionsControl: React_2.FC<ResourcePickerOptionsControlProps>;

// @public
interface ResourcePickerOptionsControlProps {
    className?: string;
    onOptionsChange: (options: ResourcePickerOptions) => void;
    options: ResourcePickerOptions;
    presentation?: 'hidden' | 'inline' | 'collapsible' | 'popup' | 'popover';
    quickBranchPaths?: string[];
    showAdvanced?: boolean;
    title?: string;
}

// @public
interface ResourcePickerProps<T = unknown> extends ViewBaseProps {
    onResourceSelect: (selection: ResourceSelection<T>) => void;
    options?: ResourcePickerOptions;
    pendingResources?: PendingResource<T>[];
    resourceAnnotations?: ResourceAnnotations;
    resources: ProcessedResources | ExtendedProcessedResources | null;
    selectedResourceId: string | null;
}

// @public
interface ResourceSelection<T = unknown> {
    isPending?: boolean;
    pendingType?: 'new' | 'modified' | 'deleted';
    resourceData?: T;
    resourceId: string | null;
}

// @public
class ResourceSelector {
    constructor();
    getRegisteredTypes(): string[];
    // Warning: (ae-forgotten-export) The symbol "SelectorHandler" needs to be exported by the entry point index.d.ts
    registerSelector(type: string, handler: SelectorHandler): void;
    select(selector: GridResourceSelector, resources: ProcessedResources): Result<string[]>;
}

declare namespace ResourceTools {
    export {
        useResourceData,
        ProcessedResources,
        ExtendedProcessedResources,
        ResourceManagerState,
        ResourceEditorFactory,
        ResourceEditorResult,
        ResourceEditorProps,
        ResourceDetailData
    }
}

// Warning: (ae-forgotten-export) The symbol "ResourceTreeViewProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResourceTreeView: React_2.FC<ResourceTreeViewProps>;

// @public
interface ResourceTypeColumnMapping {
    columns: GridColumnDefinition[];
    defaultColumn?: GridColumnDefinition;
    resourceType: string;
}

// Warning: (ae-forgotten-export) The symbol "ResourceTypeEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public
const ResourceTypeEditForm: React_2.FC<ResourceTypeEditFormProps>;

export { Result }

// @public
function selectResources(selector: GridResourceSelector, resources: ProcessedResources): Result<string[]>;

// Warning: (ae-forgotten-export) The symbol "SharedContextControlsProps" needs to be exported by the entry point index.d.ts
//
// @public
const SharedContextControls: React_2.FC<SharedContextControlsProps>;

// Warning: (ae-forgotten-export) The symbol "SourceResourceDetailProps" needs to be exported by the entry point index.d.ts
//
// @public
export const SourceResourceDetail: React_2.FC<SourceResourceDetailProps>;

// @public
export const SourceView: React_2.FC<SourceViewProps>;

// @public
interface SourceViewProps extends ViewBaseProps {
    onExport?: (data: unknown, type: 'json') => void;
    onResourceSelect?: (resourceId: string) => void;
    pickerOptions?: ResourcePickerOptions;
    resources?: ExtendedProcessedResources | null;
    selectedResourceId?: string | null;
}

// Warning: (ae-forgotten-export) The symbol "StringCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const StringCell: React_2.FC<StringCellProps>;

// Warning: (ae-forgotten-export) The symbol "TriStateCellProps" needs to be exported by the entry point index.d.ts
//
// @public
const TriStateCell: React_2.FC<TriStateCellProps>;

declare namespace TsResTools {
    export {
        SourceView,
        CompiledView,
        getDefaultSystemConfiguration,
        createSimpleContext,
        convertImportedDirectoryToFileTree,
        createTsResSystemFromConfig,
        processImportedFiles,
        processImportedDirectory,
        SourceViewProps,
        CompiledViewProps
    }
}

// Warning: (ae-forgotten-export) The symbol "UnifiedChangeControlsProps" needs to be exported by the entry point index.d.ts
//
// @public
const UnifiedChangeControls: React_2.FC<UnifiedChangeControlsProps>;

// Warning: (ae-forgotten-export) The symbol "UseConfigurationStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useConfigurationState(initialConfiguration?: Config.Model.ISystemConfiguration, onConfigurationChange?: (config: Config.Model.ISystemConfiguration) => void, onUnsavedChanges?: (hasChanges: boolean) => void): UseConfigurationStateReturn;

// Warning: (ae-forgotten-export) The symbol "UseFilterStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useFilterState(initialState?: Partial<FilterState>): UseFilterStateReturn;

// Warning: (ae-forgotten-export) The symbol "UseResolutionStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useResolutionState(processedResources: ProcessedResources | null, onMessage?: (type: 'info' | 'warning' | 'error' | 'success', message: string) => void, onSystemUpdate?: (updatedResources: ProcessedResources) => void): UseResolutionStateReturn;

// Warning: (ae-forgotten-export) The symbol "UseResourceDataParams" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "UseResourceDataReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useResourceData(params?: UseResourceDataParams): UseResourceDataReturn;

// Warning: (ae-forgotten-export) The symbol "UseViewStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
function useViewState(): UseViewStateReturn;

// Warning: (ae-forgotten-export) The symbol "CellValidationResult" needs to be exported by the entry point index.d.ts
//
// @public
function validateCellValue(value: JsonValue, validation?: GridCellValidation): Result<CellValidationResult>;

// Warning: (ae-forgotten-export) The symbol "ConfigurationValidationResult" needs to be exported by the entry point index.d.ts
//
// @public
function validateConfiguration(config: Config.Model.ISystemConfiguration): ConfigurationValidationResult;

// @public
function validatePendingResourceKeys(pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>): Result<void>;

// @public
const ValidationFunctions: {
    validJson: (value: JsonValue) => string | null;
    numberRange: (min: number, max: number) => (value: JsonValue) => string | null;
    oneOf: (allowedValues: JsonValue[]) => (value: JsonValue) => string | null;
    excludeCharacters: (forbiddenChars: string) => (value: JsonValue) => string | null;
};

// @public
const ValidationPatterns: {
    email: RegExp;
    url: RegExp;
    phone: RegExp;
    alphanumeric: RegExp;
    noWhitespace: RegExp;
    positiveInteger: RegExp;
    nonNegativeInteger: RegExp;
};

// @public
interface ViewBaseProps {
    className?: string;
    onMessage?: (type: Message['type'], message: string) => void;
    pickerOptionsPresentation?: 'hidden' | 'inline' | 'collapsible' | 'popup' | 'popover';
}

declare namespace ViewStateTools {
    export {
        MessagesWindow,
        useViewState,
        Message_2 as Message,
        MessagesWindowProps,
        ViewBaseProps
    }
}

declare namespace ZipTools {
    export {
        ImportView,
        isZipFile,
        processZipResources,
        processZipLoadResult,
        ImportViewProps
    }
}

// (No @packageDocumentation comment for this package)

```
