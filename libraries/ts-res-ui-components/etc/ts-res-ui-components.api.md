## API Report File for "@fgv/ts-res-ui-components"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Bundle } from '@fgv/ts-res';
import { Config } from '@fgv/ts-res';
import { FileTree } from '@fgv/ts-utils';
import { Import } from '@fgv/ts-res';
import { JsonValue } from '@fgv/ts-json-base';
import { Qualifiers } from '@fgv/ts-res';
import { QualifierTypes } from '@fgv/ts-res';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { ResourceJson } from '@fgv/ts-res';
import { Resources } from '@fgv/ts-res';
import { ResourceTypes } from '@fgv/ts-res';
import { Result } from '@fgv/ts-utils';
import { Runtime } from '@fgv/ts-res';

// Warning: (ae-forgotten-export) The symbol "FilterResult_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function analyzeFilteredResources(originalResourceIds: string[], filteredProcessedResources: ProcessedResources, originalProcessedResources: ProcessedResources): FilterResult_2;

// @internal (undocumented)
interface BrowserZipData {
    // (undocumented)
    config?: any;
    // (undocumented)
    files: Array<{
        path: string;
        content: string;
    }>;
    // (undocumented)
    manifest: ZipManifest;
}

// @internal (undocumented)
class BrowserZipLoader implements IZipLoader {
    loadFromBuffer(buffer: ArrayBuffer, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;
    loadFromFile(file: File, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;
    loadFromUrl(url: string, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;
}

// @public (undocumented)
export interface CandidateInfo {
    // (undocumented)
    candidate: Runtime.IResourceCandidate;
    // (undocumented)
    candidateIndex: number;
    // (undocumented)
    conditionEvaluations?: ConditionEvaluationResult[];
    // (undocumented)
    conditionSetKey: string | null;
    // (undocumented)
    isDefaultMatch: boolean;
    // (undocumented)
    matched: boolean;
    // (undocumented)
    matchType: 'match' | 'matchAsDefault' | 'noMatch';
}

// @public (undocumented)
function cloneConfiguration(config: Config.Model.ISystemConfiguration): Config.Model.ISystemConfiguration;

// @public
export const CompiledView: React_2.FC<CompiledViewProps>;

// @public
export interface CompiledViewProps extends ViewBaseProps {
    filterResult?: FilterResult | null;
    filterState?: FilterState;
    onExport?: (data: ResourceJson.Compiled.ICompiledResourceCollection | Bundle.IBundle, type: 'json' | 'bundle') => void;
    resources?: ExtendedProcessedResources | null;
    useNormalization?: boolean;
}

// @public (undocumented)
export interface ConditionEvaluationResult {
    // (undocumented)
    conditionIndex: number;
    // (undocumented)
    conditionValue: string | undefined;
    // (undocumented)
    matched: boolean;
    // (undocumented)
    matchType: 'match' | 'matchAsDefault' | 'noMatch';
    // (undocumented)
    operator: string;
    // (undocumented)
    qualifierName: string;
    // (undocumented)
    qualifierValue: string | undefined;
    // (undocumented)
    score: number;
    // (undocumented)
    scoreAsDefault?: number;
}

declare namespace ConfigurationTools {
    export {
        ConfigurationView,
        getDefaultConfiguration,
        validateConfiguration,
        cloneConfiguration,
        exportConfiguration,
        importConfiguration
    }
}

// @public
export const ConfigurationView: React_2.FC<ConfigurationViewProps>;

// @public (undocumented)
export interface ConfigurationViewProps extends ViewBaseProps {
    // (undocumented)
    configuration?: Config.Model.ISystemConfiguration | null;
    // (undocumented)
    hasUnsavedChanges?: boolean;
    // (undocumented)
    onConfigurationChange?: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    onSave?: (config: Config.Model.ISystemConfiguration) => void;
}

// @internal (undocumented)
function convertImportedDirectoryToFileTree(directory: ImportedDirectory): FileTree.FileTree;

// @internal (undocumented)
function createBrowserZipLoader(): IZipLoader;

// @public (undocumented)
const createFilteredResourceManagerSimple: (originalSystem: ProcessedResources["system"], partialContext: Record<string, string | undefined>, options?: FilterOptions) => Promise<Result<ProcessedResources>>;

// @internal (undocumented)
function createManifest(inputType: 'file' | 'directory', originalPath: string, archivePath: string, configPath?: string): ZipManifest;

// @internal (undocumented)
function createNodeZipBuilder(): IZipBuilder;

// @public (undocumented)
function createResolverWithContext(processedResources: ProcessedResources, contextValues: Record<string, string | undefined>, options?: ResolutionOptions): Result<Runtime.ResourceResolver>;

// @internal (undocumented)
function createSimpleContext(qualifiers: Qualifiers.IReadOnlyQualifierCollector, values: Record<string, string | undefined>): Result<Runtime.ValidatingSimpleContextQualifierProvider>;

// @internal (undocumented)
function createTsResSystemFromConfig(systemConfig?: Config.Model.ISystemConfiguration): Result<{
    qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
    qualifiers: Qualifiers.IReadOnlyQualifierCollector;
    resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
    resourceManager: Resources.ResourceManagerBuilder;
    importManager: Import.ImportManager;
    contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
}>;

// @public (undocumented)
export const EditableJsonView: React_2.FC<EditableJsonViewProps>;

// @public (undocumented)
export interface EditableJsonViewProps {
    className?: string;
    disabled?: boolean;
    editedValue?: any;
    isEdited?: boolean;
    onCancel?: (resourceId: string) => void;
    onSave?: (resourceId: string, editedValue: any, originalValue: any) => void;
    resourceId: string;
    value: any;
}

// @public
export interface EditedResourceInfo {
    // (undocumented)
    editedValue: JsonValue;
    // (undocumented)
    originalValue: JsonValue;
    resourceId: string;
    // (undocumented)
    timestamp: Date;
}

// @public (undocumented)
function evaluateConditionsForCandidate(resolver: Runtime.ResourceResolver, candidateIndex: number, compiledResource: any, compiledCollection: any): ConditionEvaluationResult[];

// @internal (undocumented)
function exportAsJson(data: any, filename: string): void;

// Warning: (ae-forgotten-export) The symbol "ConfigurationExportOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function exportConfiguration(config: Config.Model.ISystemConfiguration, options?: ConfigurationExportOptions): Result<string>;

// @internal (undocumented)
function exportUsingFileSystemAPI(data: any, suggestedName: string, description?: string): Promise<boolean>;

// @public
export interface ExtendedProcessedResources extends ProcessedResources {
    activeConfiguration?: Config.Model.ISystemConfiguration | null;
    bundleMetadata?: Bundle.IBundleMetadata | null;
    isLoadedFromBundle?: boolean;
}

// @internal (undocumented)
function filesToDirectory(files: ImportedFile[]): ImportedDirectory;

declare namespace FileTools {
    export {
        readFilesFromInput,
        filesToDirectory,
        exportAsJson,
        exportUsingFileSystemAPI
    }
}

// @public
export interface FilterActions {
    applyFilterValues: () => void;
    resetFilterValues: () => void;
    updateFilterEnabled: (enabled: boolean) => void;
    updateFilterValues: (values: Record<string, string | undefined>) => void;
    updateReduceQualifiers: (reduceQualifiers: boolean) => void;
}

// @public (undocumented)
export interface FilteredResource {
    // (undocumented)
    filteredCandidateCount: number;
    // (undocumented)
    hasWarning: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    originalCandidateCount: number;
}

// @public (undocumented)
interface FilterOptions {
    // (undocumented)
    enableDebugLogging?: boolean;
    // (undocumented)
    partialContextMatch?: boolean;
    // (undocumented)
    reduceQualifiers?: boolean;
}

// @public (undocumented)
export interface FilterResult {
    // (undocumented)
    error?: string;
    // (undocumented)
    filteredResources?: FilteredResource[];
    // (undocumented)
    processedResources?: ProcessedResources;
    // (undocumented)
    success: boolean;
    // (undocumented)
    warnings?: string[];
}

// @public
export interface FilterState {
    appliedValues: Record<string, string | undefined>;
    enabled: boolean;
    hasPendingChanges: boolean;
    reduceQualifiers: boolean;
    values: Record<string, string | undefined>;
}

declare namespace FilterTools {
    export {
        FilterView,
        createFilteredResourceManagerSimple,
        analyzeFilteredResources,
        hasFilterValues,
        getFilterSummary,
        FilterOptions
    }
}

// @public
export const FilterView: React_2.FC<FilterViewProps>;

// @public
export interface FilterViewProps extends ViewBaseProps {
    filterActions: FilterActions;
    filterResult?: FilterResult | null;
    filterState: FilterState;
    onFilterResult?: (result: FilterResult | null) => void;
    resources?: ProcessedResources | null;
}

// @internal (undocumented)
function formatFileSize(bytes: number): string;

// @internal (undocumented)
function generateZipFilename(customName?: string): string;

// @public (undocumented)
function getAvailableQualifiers(processedResources: ProcessedResources): string[];

// @internal (undocumented)
function getBaseName(filename: string): string;

// @public
function getDefaultConfiguration(): Config.Model.ISystemConfiguration;

// @internal (undocumented)
function getDefaultSystemConfiguration(): Config.Model.ISystemConfiguration;

// @internal (undocumented)
function getDirectoryName(path: string): string;

// @public (undocumented)
function getFilterSummary(values: Record<string, string | undefined>): string;

// @public (undocumented)
function hasFilterValues(values: Record<string, string | undefined>): boolean;

// @public (undocumented)
function hasPendingContextChanges(contextValues: Record<string, string | undefined>, pendingContextValues: Record<string, string | undefined>): boolean;

// Warning: (ae-forgotten-export) The symbol "HierarchyEditorProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const HierarchyEditor: React_2.FC<HierarchyEditorProps>;

// @public (undocumented)
function importConfiguration(data: string): Result<Config.Model.ISystemConfiguration>;

// @public
export interface ImportedDirectory {
    files: ImportedFile[];
    name: string;
    path?: string;
    subdirectories?: ImportedDirectory[];
}

// @public
export interface ImportedFile {
    content: string;
    name: string;
    path?: string;
    type?: string;
}

// @public
export const ImportView: React_2.FC<ImportViewProps>;

// @public
export interface ImportViewProps extends ViewBaseProps {
    acceptedFileTypes?: string[];
    onBundleImport?: (bundle: Bundle.IBundle) => void;
    onImport?: (data: ImportedDirectory | ImportedFile[]) => void;
    onZipImport?: (zipFile: File, config?: Config.Model.ISystemConfiguration) => void;
}

// @internal (undocumented)
function isZipFile(filename: string): boolean;

// @internal (undocumented)
interface IZipBuilder {
    createFromDirectory(directory: ImportedDirectory, options?: ZipArchiveOptions): Promise<Result<ZipArchiveResult>>;
    createFromFiles(files: ImportedFile[], options?: ZipArchiveOptions): Promise<Result<ZipArchiveResult>>;
    createFromPath(path: string, options?: ZipArchiveOptions): Promise<Result<ZipArchiveResult>>;
}

// @internal (undocumented)
interface IZipLoader {
    loadFromBuffer(buffer: ArrayBuffer, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;
    loadFromFile(file: File, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;
    loadFromUrl(url: string, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;
}

export { JsonValue }

// @internal (undocumented)
function loadZipFile(file: File, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;

// @internal (undocumented)
function loadZipFromUrl(url: string, options?: ZipLoadOptions, onProgress?: ZipProgressCallback): Promise<Result<ZipLoadResult>>;

// @public
export interface Message {
    id: string;
    message: string;
    timestamp: Date;
    type: 'info' | 'warning' | 'error' | 'success';
}

// @internal (undocumented)
class NodeZipBuilder implements IZipBuilder {
    createFromDirectory(directory: ImportedDirectory, options?: ZipArchiveOptions): Promise<Result<ZipArchiveResult>>;
    createFromFiles(files: ImportedFile[], options?: ZipArchiveOptions): Promise<Result<ZipArchiveResult>>;
    createFromPath(path: string, options?: ZipArchiveOptions): Promise<Result<ZipArchiveResult>>;
}

// @internal (undocumented)
function normalizePath(path: string): string;

// @public (undocumented)
export interface OrchestratorActions {
    // (undocumented)
    addMessage: (type: Message['type'], message: string) => void;
    // (undocumented)
    applyConfiguration: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    applyFilter: () => Promise<FilterResult | null>;
    // (undocumented)
    applyResolutionContext: () => void;
    // (undocumented)
    applyResourceEdits: () => Promise<void>;
    // (undocumented)
    clearMessages: () => void;
    // (undocumented)
    clearResourceEdits: () => void;
    // (undocumented)
    clearResources: () => void;
    // (undocumented)
    discardResourceEdits: () => void;
    // (undocumented)
    getEditedValue: (resourceId: string) => JsonValue | undefined;
    // (undocumented)
    hasResourceEdit: (resourceId: string) => boolean;
    // (undocumented)
    importBundle: (bundle: Bundle.IBundle) => Promise<void>;
    // (undocumented)
    importDirectory: (directory: ImportedDirectory) => Promise<void>;
    // (undocumented)
    importDirectoryWithConfig: (directory: ImportedDirectory, config: Config.Model.ISystemConfiguration) => Promise<void>;
    // (undocumented)
    importFiles: (files: ImportedFile[]) => Promise<void>;
    // (undocumented)
    resetFilter: () => void;
    // (undocumented)
    resetResolutionCache: () => void;
    // (undocumented)
    resolveResource: (resourceId: string, context?: Record<string, string>) => Promise<Result<JsonValue>>;
    // (undocumented)
    saveResourceEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => void;
    // (undocumented)
    selectResource: (resourceId: string | null) => void;
    // (undocumented)
    selectResourceForResolution: (resourceId: string) => void;
    // (undocumented)
    setResolutionViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;
    // (undocumented)
    updateConfiguration: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    updateFilterState: (state: Partial<FilterState>) => void;
    // (undocumented)
    updateResolutionContext: (qualifierName: string, value: string | undefined) => void;
}

// @public (undocumented)
export interface OrchestratorState {
    // (undocumented)
    configuration: Config.Model.ISystemConfiguration | null;
    // (undocumented)
    error: string | null;
    // (undocumented)
    filterResult: FilterResult | null;
    // (undocumented)
    filterState: FilterState;
    // (undocumented)
    isProcessing: boolean;
    // (undocumented)
    messages: Message[];
    // (undocumented)
    resolutionState: ResolutionState;
    // (undocumented)
    resources: ExtendedProcessedResources | null;
    // (undocumented)
    selectedResourceId: string | null;
}

// @internal (undocumented)
function parseConfiguration(configData: string): Result<Config.Model.ISystemConfiguration>;

// @internal (undocumented)
function parseManifest(manifestData: string): Result<ZipManifest>;

// @public
export interface PendingResource<T = unknown> {
    displayName?: string;
    id: string;
    resourceData?: T;
    resourceType?: string;
    type: 'new' | 'modified' | 'deleted';
}

// @internal (undocumented)
function prepareZipData(files: ImportedFile[], options?: ZipArchiveOptions): Result<BrowserZipData>;

// @internal (undocumented)
function prepareZipDataFromDirectory(directory: ImportedDirectory, options?: ZipArchiveOptions): Result<BrowserZipData>;

// @public
export interface ProcessedResources {
    compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;
    resolver: Runtime.ResourceResolver;
    resourceCount: number;
    summary: {
        totalResources: number;
        resourceIds: string[];
        errorCount: number;
        warnings: string[];
    };
    system: {
        resourceManager: Resources.ResourceManagerBuilder;
        qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
        qualifiers: Qualifiers.IReadOnlyQualifierCollector;
        resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
        importManager: Import.ImportManager;
        contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
    };
}

// @internal (undocumented)
function processImportedDirectory(directory: ImportedDirectory, systemConfig?: Config.Model.ISystemConfiguration): Result<{
    system: {
        qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
        qualifiers: Qualifiers.IReadOnlyQualifierCollector;
        resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
        resourceManager: Resources.ResourceManagerBuilder;
        importManager: Import.ImportManager;
        contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
    };
    compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;
    resolver: Runtime.ResourceResolver;
    resourceCount: number;
    summary: {
        totalResources: number;
        resourceIds: string[];
        errorCount: number;
        warnings: string[];
    };
}>;

// @internal (undocumented)
function processImportedFiles(files: ImportedFile[], systemConfig?: Config.Model.ISystemConfiguration): Result<{
    system: {
        qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;
        qualifiers: Qualifiers.IReadOnlyQualifierCollector;
        resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;
        resourceManager: Resources.ResourceManagerBuilder;
        importManager: Import.ImportManager;
        contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;
    };
    compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;
    resolver: Runtime.ResourceResolver;
    resourceCount: number;
    summary: {
        totalResources: number;
        resourceIds: string[];
        errorCount: number;
        warnings: string[];
    };
}>;

// Warning: (ae-forgotten-export) The symbol "QualifierContextControlProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const QualifierContextControl: React_2.FC<QualifierContextControlProps>;

// Warning: (ae-forgotten-export) The symbol "QualifierEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const QualifierEditForm: React_2.FC<QualifierEditFormProps>;

// Warning: (ae-forgotten-export) The symbol "QualifierTypeEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const QualifierTypeEditForm: React_2.FC<QualifierTypeEditFormProps>;

// @internal (undocumented)
function readFilesFromInput(files: FileList): Promise<ImportedFile[]>;

// @public (undocumented)
export interface ResolutionActions {
    // (undocumented)
    applyContext: () => void;
    // (undocumented)
    applyEdits: () => Promise<void>;
    // (undocumented)
    clearEdits: () => void;
    // (undocumented)
    discardEdits: () => void;
    // (undocumented)
    getEditedValue: (resourceId: string) => JsonValue | undefined;
    // (undocumented)
    hasEdit: (resourceId: string) => boolean;
    // (undocumented)
    resetCache: () => void;
    // (undocumented)
    saveEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => void;
    // (undocumented)
    selectResource: (resourceId: string) => void;
    // (undocumented)
    setViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;
    // (undocumented)
    updateContextValue: (qualifierName: string, value: string | undefined) => void;
}

// Warning: (ae-forgotten-export) The symbol "ResolutionEditControlsProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ResolutionEditControls: React_2.FC<ResolutionEditControlsProps>;

// @public (undocumented)
interface ResolutionOptions {
    // (undocumented)
    enableCaching?: boolean;
    // (undocumented)
    enableDebugLogging?: boolean;
}

// @public (undocumented)
export interface ResolutionResult {
    // (undocumented)
    allCandidates?: readonly Runtime.IResourceCandidate[];
    // (undocumented)
    bestCandidate?: Runtime.IResourceCandidate;
    // (undocumented)
    candidateDetails?: CandidateInfo[];
    // (undocumented)
    composedValue?: JsonValue;
    // (undocumented)
    error?: string;
    // (undocumented)
    resource?: Runtime.IResource;
    // (undocumented)
    resourceId: string;
    // (undocumented)
    success: boolean;
}

// Warning: (ae-forgotten-export) The symbol "ResolutionResultsProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ResolutionResults: React_2.FC<ResolutionResultsProps>;

// @public (undocumented)
export interface ResolutionState {
    // (undocumented)
    contextValues: Record<string, string | undefined>;
    // (undocumented)
    currentResolver: Runtime.ResourceResolver | null;
    // (undocumented)
    editedResources: Map<string, JsonValue>;
    // (undocumented)
    hasPendingChanges: boolean;
    // (undocumented)
    hasUnsavedEdits: boolean;
    // (undocumented)
    isApplyingEdits: boolean;
    // (undocumented)
    pendingContextValues: Record<string, string | undefined>;
    // (undocumented)
    resolutionResult: ResolutionResult | null;
    // (undocumented)
    selectedResourceId: string | null;
    // (undocumented)
    viewMode: 'composed' | 'best' | 'all' | 'raw';
}

declare namespace ResolutionTools {
    export {
        ResolutionView,
        createResolverWithContext,
        evaluateConditionsForCandidate,
        resolveResourceDetailed,
        getAvailableQualifiers,
        hasPendingContextChanges,
        ResolutionOptions
    }
}

// @public
export const ResolutionView: React_2.FC<ResolutionViewProps>;

// @public
export interface ResolutionViewProps extends ViewBaseProps {
    availableQualifiers?: string[];
    filterResult?: FilterResult | null;
    filterState?: FilterState;
    resolutionActions?: ResolutionActions;
    resolutionState?: ResolutionState;
    resourceEditorFactory?: ResourceEditorFactory;
    resources?: ProcessedResources | null;
}

// @public (undocumented)
function resolveResourceDetailed(resolver: Runtime.ResourceResolver, resourceId: string, processedResources: ProcessedResources, options?: ResolutionOptions): Result<ResolutionResult>;

// @public
export interface ResourceAnnotation {
    badge?: {
        text: string;
        variant: 'info' | 'warning' | 'success' | 'error' | 'edited' | 'new';
    };
    className?: string;
    indicator?: {
        type: 'dot' | 'icon' | 'text';
        value: string | React_2.ReactNode;
        tooltip?: string;
    };
    suffix?: React_2.ReactNode;
}

// @public
export interface ResourceAnnotations {
    [resourceId: string]: ResourceAnnotation;
}

// @public (undocumented)
export interface ResourceDetailData {
    // (undocumented)
    candidateCount: number;
    // (undocumented)
    candidates: Array<{
        json: JsonValue;
        conditions: Array<{
            qualifier: string;
            operator: string;
            value: string;
            priority: number;
            scoreAsDefault?: number;
        }>;
        isPartial: boolean;
        mergeMethod: string;
    }>;
    // (undocumented)
    id: string;
    // (undocumented)
    resourceType: string;
}

// @public
export interface ResourceEditorFactory {
    createEditor(resourceId: string, resourceType: string, value: any): ResourceEditorResult;
}

// @public
export interface ResourceEditorProps {
    className?: string;
    disabled?: boolean;
    editedValue?: any;
    isEdited?: boolean;
    onCancel?: (resourceId: string) => void;
    onSave?: (resourceId: string, editedValue: any, originalValue: any) => void;
    resourceId: string;
    value: any;
}

// @public
export type ResourceEditorResult = {
    success: true;
    editor: React.ComponentType<ResourceEditorProps>;
} | {
    success: false;
    message?: string;
};

// Warning: (ae-forgotten-export) The symbol "ResourceListViewProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ResourceListView: React_2.FC<ResourceListViewProps>;

// @public
export interface ResourceManagerState {
    activeConfiguration: Config.Model.ISystemConfiguration | null;
    bundleMetadata: Bundle.IBundleMetadata | null;
    error: string | null;
    hasProcessedData: boolean;
    isLoadedFromBundle: boolean;
    isProcessing: boolean;
    processedResources: ExtendedProcessedResources | null;
}

// Warning: (ae-forgotten-export) The symbol "ResourceOrchestratorProps" needs to be exported by the entry point index.d.ts
//
// @public
export const ResourceOrchestrator: React_2.FC<ResourceOrchestratorProps>;

// @public
export const ResourcePicker: <T = unknown>({ resources, selectedResourceId, onResourceSelect, defaultView, showViewToggle, rootPath, hideRootNode, enableSearch, searchPlaceholder, searchScope, resourceAnnotations, pendingResources, emptyMessage, height, className, onMessage }: ResourcePickerProps<T>) => React_2.JSX.Element;

// @public
export interface ResourcePickerProps<T = unknown> extends ViewBaseProps {
    defaultView?: 'list' | 'tree';
    emptyMessage?: string;
    enableSearch?: boolean;
    height?: string | number;
    hideRootNode?: boolean;
    onResourceSelect: (selection: ResourceSelection<T>) => void;
    pendingResources?: PendingResource<T>[];
    resourceAnnotations?: ResourceAnnotations;
    resources: ProcessedResources | ExtendedProcessedResources | null;
    rootPath?: string;
    searchPlaceholder?: string;
    searchScope?: 'all' | 'current-branch';
    selectedResourceId: string | null;
    showViewToggle?: boolean;
}

// @public
export interface ResourceSelection<T = unknown> {
    isPending?: boolean;
    pendingType?: 'new' | 'modified' | 'deleted';
    resourceData?: T;
    resourceId: string | null;
}

// Warning: (ae-forgotten-export) The symbol "ResourceTreeViewProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ResourceTreeView: React_2.FC<ResourceTreeViewProps>;

// Warning: (ae-forgotten-export) The symbol "ResourceTypeEditFormProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const ResourceTypeEditForm: React_2.FC<ResourceTypeEditFormProps>;

export { Result }

// @internal (undocumented)
function sanitizeFilename(filename: string): string;

// Warning: (ae-forgotten-export) The symbol "SourceResourceDetailProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const SourceResourceDetail: React_2.FC<SourceResourceDetailProps>;

// @public
export const SourceView: React_2.FC<SourceViewProps>;

// @public
export interface SourceViewProps extends ViewBaseProps {
    onExport?: (data: unknown, type: 'json') => void;
    onResourceSelect?: (resourceId: string) => void;
    resources?: ExtendedProcessedResources | null;
    selectedResourceId?: string | null;
}

declare namespace TsResTools {
    export {
        SourceView,
        CompiledView,
        getDefaultSystemConfiguration,
        createSimpleContext,
        convertImportedDirectoryToFileTree,
        createTsResSystemFromConfig,
        processImportedFiles,
        processImportedDirectory
    }
}

// Warning: (ae-forgotten-export) The symbol "UseConfigurationStateReturn" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useConfigurationState(initialConfiguration?: Config.Model.ISystemConfiguration, onConfigurationChange?: (config: Config.Model.ISystemConfiguration) => void, onUnsavedChanges?: (hasChanges: boolean) => void): UseConfigurationStateReturn;

// Warning: (ae-forgotten-export) The symbol "UseFilterStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
export function useFilterState(initialState?: Partial<FilterState>): UseFilterStateReturn;

// Warning: (ae-forgotten-export) The symbol "UseResolutionStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
export function useResolutionState(processedResources: ProcessedResources | null, onMessage?: (type: 'info' | 'warning' | 'error' | 'success', message: string) => void, onSystemUpdate?: (updatedResources: ProcessedResources) => void): UseResolutionStateReturn;

// Warning: (ae-forgotten-export) The symbol "UseResourceDataReturn" needs to be exported by the entry point index.d.ts
//
// @public
export function useResourceData(): UseResourceDataReturn;

// Warning: (ae-forgotten-export) The symbol "UseViewStateReturn" needs to be exported by the entry point index.d.ts
//
// @public
export function useViewState(): UseViewStateReturn;

// Warning: (ae-forgotten-export) The symbol "ConfigurationValidationResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function validateConfiguration(config: Config.Model.ISystemConfiguration): ConfigurationValidationResult;

// @public
export interface ViewBaseProps {
    className?: string;
    onMessage?: (type: Message['type'], message: string) => void;
}

// @internal (undocumented)
interface ZipArchiveOptions {
    compressionLevel?: number;
    config?: Config.Model.ISystemConfiguration;
    filename?: string;
    includeConfig?: boolean;
    outputDir?: string;
}

// @internal (undocumented)
interface ZipArchiveResult {
    filePath: string;
    fileSize: number;
    manifest: ZipManifest;
    timestamp: string;
}

// @internal (undocumented)
interface ZipFileItem {
    // (undocumented)
    content?: string | ArrayBuffer;
    // (undocumented)
    isDirectory: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    name: string;
    // (undocumented)
    path: string;
    // (undocumented)
    size: number;
}

// @internal (undocumented)
interface ZipFileTree {
    // (undocumented)
    directories: Set<string>;
    // (undocumented)
    files: Map<string, ZipFileItem>;
    // (undocumented)
    root: string;
}

// @public
export const ZipLoaderView: React_2.FC<ZipLoaderViewProps>;

// @public (undocumented)
export interface ZipLoaderViewProps extends ViewBaseProps {
    // (undocumented)
    onConfigurationLoad?: (config: Config.Model.ISystemConfiguration) => void;
    // (undocumented)
    onImport?: (data: ImportedDirectory | ImportedFile[]) => void;
    // (undocumented)
    onLoadComplete?: () => void;
    // (undocumented)
    zipFileUrl?: string;
    // (undocumented)
    zipPath?: string;
}

// @internal (undocumented)
type ZipLoadingStage = 'reading-file' | 'parsing-zip' | 'loading-manifest' | 'loading-config' | 'extracting-files' | 'processing-resources' | 'complete';

// @internal (undocumented)
interface ZipLoadOptions {
    autoApplyConfig?: boolean;
    autoProcessResources?: boolean;
    overrideConfig?: Config.Model.ISystemConfiguration;
}

// @internal (undocumented)
interface ZipLoadResult {
    config: Config.Model.ISystemConfiguration | null;
    directory: ImportedDirectory | null;
    files: ImportedFile[];
    fileTree?: any;
    manifest: ZipManifest | null;
    processedResources: ProcessedResources | null;
}

// @internal (undocumented)
interface ZipManifest {
    // (undocumented)
    config?: {
        type: 'file';
        originalPath: string;
        archivePath: string;
    };
    // (undocumented)
    input?: {
        type: 'file' | 'directory';
        originalPath: string;
        archivePath: string;
    };
    // (undocumented)
    timestamp: string;
}

// @internal (undocumented)
interface ZipProgressCallback {
    // (undocumented)
    (stage: ZipLoadingStage, progress: number, message?: string): void;
}

declare namespace ZipTools {
    export {
        ImportView,
        ZipLoaderView,
        BrowserZipLoader,
        createBrowserZipLoader,
        loadZipFile,
        loadZipFromUrl,
        NodeZipBuilder,
        createNodeZipBuilder,
        BrowserZipData,
        prepareZipData,
        prepareZipDataFromDirectory,
        generateZipFilename,
        createManifest,
        parseManifest,
        parseConfiguration,
        zipTreeToFiles,
        zipTreeToDirectory,
        normalizePath,
        getDirectoryName,
        sanitizeFilename,
        formatFileSize,
        isZipFile,
        getBaseName,
        ZipManifest,
        ZipArchiveOptions,
        ZipArchiveResult,
        ZipLoadOptions,
        ZipLoadResult,
        ZipLoadingStage,
        ZipProgressCallback,
        IZipBuilder,
        IZipLoader,
        ZipFileItem,
        ZipFileTree
    }
}

// @internal (undocumented)
function zipTreeToDirectory(tree: ZipFileTree): ImportedDirectory | null;

// @internal (undocumented)
function zipTreeToFiles(tree: ZipFileTree): ImportedFile[];

// (No @packageDocumentation comment for this package)

```
