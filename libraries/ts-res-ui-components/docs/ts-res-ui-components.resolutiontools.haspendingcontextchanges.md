<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@fgv/ts-res-ui-components](./ts-res-ui-components.md) &gt; [ResolutionTools](./ts-res-ui-components.resolutiontools.md) &gt; [hasPendingContextChanges](./ts-res-ui-components.resolutiontools.haspendingcontextchanges.md)

## ResolutionTools.hasPendingContextChanges() function

Check if context has any pending changes by comparing current and pending values.

Performs a deep comparison between current context values and pending context values to determine if there are unsaved changes. This is useful for UI state management and preventing data loss in resolution interfaces.

**Signature:**

```typescript
export declare function hasPendingContextChanges(contextValues: Record<string, string | undefined>, pendingContextValues: Record<string, string | undefined>): boolean;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

contextValues


</td><td>

Record&lt;string, string \| undefined&gt;


</td><td>

The current/saved context values


</td></tr>
<tr><td>

pendingContextValues


</td><td>

Record&lt;string, string \| undefined&gt;


</td><td>

The pending/unsaved context values


</td></tr>
</tbody></table>

**Returns:**

boolean

True if there are pending changes, false if contexts are identical

## Example 1


```typescript
import { ResolutionTools } from '@fgv/ts-res-ui-components';

// Check for unsaved context changes in resolution UI
const ResolutionInterface = () => {
  const [savedContext, setSavedContext] = useState({
    language: 'en-US',
    platform: 'web'
  });

  const [pendingContext, setPendingContext] = useState(savedContext);

  const hasChanges = ResolutionTools.hasPendingContextChanges(
    savedContext,
    pendingContext
  );

  const handleApplyChanges = () => {
    if (hasChanges) {
      setSavedContext(pendingContext);
      // Trigger re-resolution with new context...
    }
  };

  return (
    <div>
      {hasChanges && (
        <div className="warning">
          You have unsaved context changes.
          <button onClick={handleApplyChanges}>Apply Changes</button>
        </div>
      )}
    </div>
  );
};
```

## Example 2


```typescript
// Prevent navigation with unsaved changes
function useUnsavedChangesWarning(
  currentContext: Record<string, string | undefined>,
  pendingContext: Record<string, string | undefined>
) {
  const hasChanges = ResolutionTools.hasPendingContextChanges(
    currentContext,
    pendingContext
  );

  useEffect(() => {
    const handleBeforeUnload = (event: BeforeUnloadEvent) => {
      if (hasChanges) {
        event.preventDefault();
        event.returnValue = 'You have unsaved context changes. Are you sure you want to leave?';
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [hasChanges]);

  return hasChanges;
}
```

## Example 3


```typescript
// Context change management in resolution workflow
class ResolutionContextManager {
  private savedContext: Record<string, string | undefined> = {};
  private pendingContext: Record<string, string | undefined> = {};

  updatePendingValue(qualifier: string, value: string | undefined) {
    this.pendingContext = { ...this.pendingContext, [qualifier]: value };
  }

  hasPendingChanges(): boolean {
    return ResolutionTools.hasPendingContextChanges(
      this.savedContext,
      this.pendingContext
    );
  }

  applyChanges(): boolean {
    if (this.hasPendingChanges()) {
      this.savedContext = { ...this.pendingContext };
      return true; // Changes were applied
    }
    return false; // No changes to apply
  }

  discardChanges(): boolean {
    if (this.hasPendingChanges()) {
      this.pendingContext = { ...this.savedContext };
      return true; // Changes were discarded
    }
    return false; // No changes to discard
  }
}
```

