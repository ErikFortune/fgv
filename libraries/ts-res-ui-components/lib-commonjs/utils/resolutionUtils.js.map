{"version":3,"file":"resolutionUtils.js","sourceRoot":"","sources":["../../src/utils/resolutionUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Result, succeed, fail, MessageAggregator } from '@fgv/ts-utils';\nimport { Runtime } from '@fgv/ts-res';\nimport { ProcessedResources, ResolutionResult, CandidateInfo, ConditionEvaluationResult } from '../types';\n\n/**\n * Configuration options for resource resolution operations.\n *\n * ResolutionOptions provides control over performance and debugging features\n * during resource resolution operations. These options affect resolver creation,\n * resolution processing, and diagnostic output.\n *\n * @example\n * ```typescript\n * import { ResolutionTools } from '@fgv/ts-res-ui-components';\n *\n * // Basic resolution with default options\n * const basicResolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   { language: 'en-US', platform: 'web' }\n * );\n *\n * // Resolution with caching enabled for performance\n * const cachedResolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   { language: 'en-US', region: 'US' },\n *   { enableCaching: true }\n * );\n *\n * // Resolution with debugging for troubleshooting\n * const debugResolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   { language: 'fr-CA', platform: 'mobile' },\n *   { enableDebugLogging: true }\n * );\n *\n * // Full-featured resolution with both caching and debugging\n * const fullResolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   { language: 'es-MX', region: 'MX', platform: 'desktop' },\n *   { enableCaching: true, enableDebugLogging: true }\n * );\n * ```\n *\n * @public\n */\nexport interface ResolutionOptions {\n  /** Enable caching for improved performance during repeated resolutions */\n  enableCaching?: boolean;\n  /** Enable detailed console logging for debugging resolution processes */\n  enableDebugLogging?: boolean;\n}\n\n// Helper function for conditional debug logging\nconst debugLog = (enableDebug: boolean, ...args: any[]) => {\n  if (enableDebug) {\n    console.log(...args);\n  }\n};\n\n/**\n * Create a resolver with context for resource resolution.\n *\n * Creates a fully configured ResourceResolver with the specified context values\n * and options. The resolver can be used to resolve resources based on the provided\n * qualification context, with optional caching and debugging features.\n *\n * @param processedResources - The processed resource system containing all resources and configuration\n * @param contextValues - Context values for qualification (e.g., language, region, platform)\n * @param options - Configuration options for resolution behavior\n * @returns A Result containing the configured ResourceResolver or an error message\n *\n * @example\n * ```typescript\n * import { ResolutionTools } from '@fgv/ts-res-ui-components';\n *\n * // Basic resolver creation for web platform\n * const webResolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   {\n *     language: 'en-US',\n *     platform: 'web',\n *     region: 'US'\n *   }\n * );\n *\n * if (webResolver.isSuccess()) {\n *   const resolver = webResolver.value;\n *   // Use resolver to resolve resources...\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Resolver with caching for performance-critical scenarios\n * const performanceResolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   {\n *     language: 'fr-CA',\n *     platform: 'mobile',\n *     deviceType: 'tablet'\n *   },\n *   { enableCaching: true }\n * );\n * ```\n *\n * @example\n * ```typescript\n * // Resolver with debugging for troubleshooting resolution issues\n * const debugResolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   {\n *     language: 'es-MX',\n *     region: 'MX',\n *     platform: 'desktop'\n *   },\n *   { enableDebugLogging: true }\n * ).onSuccess((resolver) => {\n *   // Debug output will show context creation and resolver setup\n *   console.log('Resolver created with debug logging enabled');\n *   return succeed(resolver);\n * });\n * ```\n *\n * @public\n */\nexport function createResolverWithContext(\n  processedResources: ProcessedResources,\n  contextValues: Record<string, string | undefined>,\n  options: ResolutionOptions = {}\n): Result<Runtime.ResourceResolver> {\n  const enableDebug = options.enableDebugLogging === true;\n\n  debugLog(enableDebug, '=== CREATING RESOLVER WITH CONTEXT ===');\n  debugLog(enableDebug, 'Context values:', contextValues);\n\n  // Create context provider with filtered values (remove undefined)\n  const filteredContext = Object.fromEntries(\n    Object.entries(contextValues).filter(([, value]) => value !== undefined)\n  ) as Record<string, string>;\n\n  return Runtime.ValidatingSimpleContextQualifierProvider.create({\n    qualifiers: processedResources.system.qualifiers\n  })\n    .withErrorFormat((e) => `Failed to create context provider: ${e}`)\n    .onSuccess((contextProvider) => {\n      const errors = new MessageAggregator();\n      // Set context values\n      for (const [qualifierName, value] of Object.entries(filteredContext)) {\n        contextProvider.validating\n          .set(qualifierName, value)\n          .withErrorFormat((e) => `Failed to set context value ${qualifierName}=${value}: ${e}`)\n          .aggregateError(errors);\n      }\n\n      if (errors.hasMessages) {\n        return fail(`Errors setting context values: ${errors.toString()}`);\n      }\n\n      // Create resolver\n      const resolverParams: any = {\n        resourceManager: processedResources.system.resourceManager,\n        qualifierTypes: processedResources.system.qualifierTypes,\n        contextQualifierProvider: contextProvider\n      };\n\n      // Add cache metrics listener if caching is enabled\n      if (options.enableCaching) {\n        const metricsListener = new Runtime.ResourceResolverCacheMetricsListener(\n          () => new Runtime.AggregateCacheMetrics()\n        );\n        resolverParams.listener = metricsListener;\n      }\n\n      return Runtime.ResourceResolver.create(resolverParams)\n        .withErrorFormat((e) => `Failed to create resolver: ${e}`)\n        .onSuccess((resolver) => {\n          debugLog(enableDebug, 'Resolver created successfully');\n          return succeed(resolver);\n        });\n    });\n}\n\n/**\n * Evaluate conditions for a specific candidate and return detailed evaluation results.\n *\n * Analyzes how each condition in a candidate's condition set evaluates against the\n * current resolution context. This provides detailed insight into why a candidate\n * matches or doesn't match, including qualification values, condition operators,\n * match scores, and match types.\n *\n * @param resolver - The configured ResourceResolver with context\n * @param candidateIndex - Zero-based index of the candidate to evaluate\n * @param compiledResource - The compiled resource containing decision information\n * @param compiledCollection - The compiled collection with condition and qualifier data\n * @returns Array of condition evaluation results showing how each condition performed\n *\n * @example\n * ```typescript\n * import { ResolutionTools } from '@fgv/ts-res-ui-components';\n *\n * // Evaluate conditions for the first candidate of a resource\n * const resolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   { language: 'en-US', platform: 'web' }\n * ).orThrow();\n *\n * const compiledResource = processedResources.compiledCollection.resources\n *   .find(r => r.id === 'welcome-message');\n *\n * const evaluations = ResolutionTools.evaluateConditionsForCandidate(\n *   resolver,\n *   0, // First candidate\n *   compiledResource,\n *   processedResources.compiledCollection\n * );\n *\n * // Analyze the results\n * evaluations.forEach(evaluation => {\n *   console.log(`${evaluation.qualifierName}: ${evaluation.qualifierValue} ${evaluation.operator} ${evaluation.conditionValue}`);\n *   console.log(`  Matched: ${evaluation.matched}, Score: ${evaluation.score}`);\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Use in resolution analysis to understand candidate selection\n * function analyzeResourceResolution(resourceId: string) {\n *   const resolver = ResolutionTools.createResolverWithContext(\n *     processedResources,\n *     getCurrentContext()\n *   ).orThrow();\n *\n *   const resource = processedResources.system.resourceManager\n *     .getBuiltResource(resourceId).orThrow();\n *\n *   const compiledResource = processedResources.compiledCollection.resources\n *     .find(r => r.id === resourceId);\n *\n *   // Evaluate all candidates\n *   resource.candidates.forEach((candidate, index) => {\n *     const evaluations = ResolutionTools.evaluateConditionsForCandidate(\n *       resolver,\n *       index,\n *       compiledResource,\n *       processedResources.compiledCollection\n *     );\n *\n *     console.log(`Candidate ${index}:`);\n *     evaluations.forEach(eval => {\n *       console.log(`  ${eval.qualifierName}: ${eval.matched ? '✓' : '✗'} (${eval.score})`);\n *     });\n *   });\n * }\n * ```\n *\n * @public\n */\nexport function evaluateConditionsForCandidate(\n  resolver: Runtime.ResourceResolver,\n  candidateIndex: number,\n  compiledResource: any,\n  compiledCollection: any\n): ConditionEvaluationResult[] {\n  try {\n    const decision = compiledCollection.decisions[compiledResource.decision];\n    if (!decision || !decision.conditionSets || candidateIndex >= decision.conditionSets.length) {\n      return [];\n    }\n\n    const conditionSetIndex = decision.conditionSets[candidateIndex];\n    const conditionSet = compiledCollection.conditionSets[conditionSetIndex];\n    if (!conditionSet || !conditionSet.conditions) {\n      return [];\n    }\n\n    const evaluations: ConditionEvaluationResult[] = [];\n\n    for (const conditionIndex of conditionSet.conditions) {\n      const condition = compiledCollection.conditions[conditionIndex];\n      if (!condition) continue;\n\n      const qualifier = compiledCollection.qualifiers[condition.qualifierIndex];\n      if (!qualifier) continue;\n\n      // Get the qualifier value from context\n      const qualifierValueResult = resolver.contextQualifierProvider.get(qualifier);\n      const qualifierValue = qualifierValueResult.orDefault();\n\n      // Get the cached condition result from resolver (if available)\n      const cachedResult = resolver.conditionCache?.[conditionIndex];\n      const score = cachedResult?.score || 0;\n      const matchType = cachedResult?.matchType || 'noMatch';\n      const matched = matchType !== 'noMatch';\n\n      evaluations.push({\n        qualifierName: qualifier.name,\n        qualifierValue,\n        conditionValue: condition.value,\n        operator: condition.operator || 'matches',\n        score,\n        matched,\n        matchType,\n        scoreAsDefault: condition.scoreAsDefault,\n        conditionIndex\n      });\n    }\n\n    return evaluations;\n  } catch (error) {\n    console.warn('Error evaluating conditions for candidate:', error);\n    return [];\n  }\n}\n\n/**\n * Resolve a resource and create detailed resolution result with comprehensive analysis.\n *\n * Performs complete resource resolution including best candidate selection, all candidate\n * analysis, composed value resolution, and detailed condition evaluation for each candidate.\n * This provides the most comprehensive view of how resource resolution works for a given\n * resource and context.\n *\n * @param resolver - The configured ResourceResolver with context\n * @param resourceId - The ID of the resource to resolve\n * @param processedResources - The processed resource system\n * @param options - Configuration options for resolution behavior\n * @returns A Result containing detailed resolution information or an error\n *\n * @example\n * ```typescript\n * import { ResolutionTools } from '@fgv/ts-res-ui-components';\n *\n * // Detailed resolution of a welcome message\n * const resolver = ResolutionTools.createResolverWithContext(\n *   processedResources,\n *   { language: 'en-US', platform: 'web', region: 'US' }\n * ).orThrow();\n *\n * const result = ResolutionTools.resolveResourceDetailed(\n *   resolver,\n *   'welcome-message',\n *   processedResources\n * );\n *\n * if (result.isSuccess() && result.value.success) {\n *   const resolution = result.value;\n *   console.log('Best candidate:', resolution.bestCandidate);\n *   console.log('Composed value:', resolution.composedValue);\n *\n *   // Analyze each candidate\n *   resolution.candidateDetails.forEach((candidate, index) => {\n *     console.log(`Candidate ${index}: ${candidate.matched ? 'MATCHED' : 'no match'}`);\n *     candidate.conditionEvaluations.forEach(eval => {\n *       console.log(`  ${eval.qualifierName}: ${eval.matched ? '✓' : '✗'}`);\n *     });\n *   });\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Resolution with debugging for troubleshooting\n * const debugResult = ResolutionTools.resolveResourceDetailed(\n *   resolver,\n *   'error-messages',\n *   processedResources,\n *   { enableDebugLogging: true }\n * );\n *\n * // Debug output will show detailed resolution steps\n * ```\n *\n * @example\n * ```typescript\n * // Use in resolution testing workflow\n * async function testResourceResolution(resourceId: string, context: Record<string, string>) {\n *   const resolver = ResolutionTools.createResolverWithContext(\n *     processedResources,\n *     context\n *   ).orThrow();\n *\n *   const result = ResolutionTools.resolveResourceDetailed(\n *     resolver,\n *     resourceId,\n *     processedResources\n *   );\n *\n *   if (result.isSuccess() && result.value.success) {\n *     const resolution = result.value;\n *\n *     return {\n *       resourceId,\n *       context,\n *       bestValue: resolution.bestCandidate?.value,\n *       composedValue: resolution.composedValue,\n *       matchedCandidates: resolution.candidateDetails.filter(c => c.matched).length,\n *       totalCandidates: resolution.candidateDetails.length,\n *       conditionAnalysis: resolution.candidateDetails.map(c => ({\n *         matched: c.matched,\n *         matchType: c.matchType,\n *         conditions: c.conditionEvaluations.length\n *       }))\n *     };\n *   }\n *\n *   throw new Error(`Resolution failed: ${result.value.error}`);\n * }\n * ```\n *\n * @public\n */\nexport function resolveResourceDetailed(\n  resolver: Runtime.ResourceResolver,\n  resourceId: string,\n  processedResources: ProcessedResources,\n  options: ResolutionOptions = {}\n): Result<ResolutionResult> {\n  const enableDebug = options.enableDebugLogging === true;\n\n  debugLog(enableDebug, '=== RESOLVING RESOURCE ===');\n  debugLog(enableDebug, 'Resource ID:', resourceId);\n\n  const resourceResult = processedResources.system.resourceManager.getBuiltResource(resourceId);\n  if (resourceResult.isFailure()) {\n    return succeed({\n      success: false,\n      resourceId,\n      error: `Failed to get resource: ${resourceResult.message}`\n    });\n  }\n\n  const resource = resourceResult.value;\n  const compiledCollection = processedResources.compiledCollection;\n\n  // Find the compiled resource for condition analysis\n  const compiledResource = compiledCollection.resources.find((r) => r.id === resourceId);\n  if (!compiledResource) {\n    return succeed({\n      success: false,\n      resourceId,\n      error: 'Failed to find compiled resource'\n    });\n  }\n\n  // Resolve best candidate\n  const bestResult = resolver.resolveResource(resource);\n\n  // Resolve all candidates\n  const allResult = resolver.resolveAllResourceCandidates(resource);\n\n  // Resolve composed value\n  const composedResult = resolver.resolveComposedResourceValue(resource);\n\n  // Get decision resolution result\n  const decisionResult = resolver.resolveDecision(resource.decision.baseDecision);\n  if (decisionResult.isFailure()) {\n    return succeed({\n      success: false,\n      resourceId,\n      error: `Failed to resolve decision: ${decisionResult.message}`\n    });\n  }\n\n  const decision = decisionResult.value;\n\n  // Build detailed candidate information\n  const candidateDetails: CandidateInfo[] = [];\n  const matchedCandidates = allResult.isSuccess() ? allResult.value : [];\n\n  // Create lookup sets for regular and default matches\n  const regularMatchIndices = new Set(decision?.success ? decision.instanceIndices : []);\n  const defaultMatchIndices = new Set(decision?.success ? decision.defaultInstanceIndices : []);\n\n  // Add matched candidates first\n  matchedCandidates.forEach((matchedCandidate) => {\n    const index = resource.candidates.findIndex((candidate: any) => candidate === matchedCandidate);\n    if (index !== -1) {\n      const conditionSetKey = `cs-${index}`;\n      const conditionEvaluations = evaluateConditionsForCandidate(\n        resolver,\n        index,\n        compiledResource,\n        compiledCollection\n      );\n\n      const isDefaultMatch = defaultMatchIndices.has(index);\n      const isRegularMatch = regularMatchIndices.has(index);\n\n      const candidateMatchType = isRegularMatch ? 'match' : isDefaultMatch ? 'matchAsDefault' : 'noMatch';\n\n      candidateDetails.push({\n        candidate: resource.candidates[index],\n        conditionSetKey,\n        candidateIndex: index,\n        matched: true,\n        matchType: candidateMatchType,\n        isDefaultMatch,\n        conditionEvaluations\n      });\n    }\n  });\n\n  // Add non-matching candidates\n  resource.candidates.forEach((candidate: any, index: number) => {\n    const isMatched = matchedCandidates.some((mc) => mc === candidate);\n    if (!isMatched) {\n      // Handle different candidate formats - IResourceCandidate doesn't have conditions\n      const conditionSetKey = candidate.conditions?.toHash ? candidate.conditions.toHash() : `cs-${index}`;\n      const conditionEvaluations = evaluateConditionsForCandidate(\n        resolver,\n        index,\n        compiledResource,\n        compiledCollection\n      );\n\n      candidateDetails.push({\n        candidate,\n        conditionSetKey,\n        candidateIndex: index,\n        matched: false,\n        matchType: 'noMatch',\n        isDefaultMatch: false,\n        conditionEvaluations\n      });\n    }\n  });\n\n  const result: ResolutionResult = {\n    success: true,\n    resourceId,\n    resource,\n    bestCandidate: bestResult.isSuccess() ? bestResult.value : undefined,\n    allCandidates: allResult.isSuccess() ? allResult.value : undefined,\n    candidateDetails,\n    composedValue: composedResult.isSuccess() ? composedResult.value : undefined,\n    error: bestResult.isFailure() ? bestResult.message : undefined\n  };\n\n  debugLog(enableDebug, 'Resolution completed successfully');\n  return succeed(result);\n}\n\n/**\n * Get available qualifiers from processed resources.\n *\n * Extracts all qualifier names from the compiled resource collection, providing\n * a list of qualification dimensions available for context setting and resource\n * resolution. This is useful for building dynamic UI controls and validation.\n *\n * @param processedResources - The processed resource system\n * @returns Array of qualifier names available in the system\n *\n * @example\n * ```typescript\n * import { ResolutionTools } from '@fgv/ts-res-ui-components';\n *\n * // Get all available qualifiers for UI generation\n * const availableQualifiers = ResolutionTools.getAvailableQualifiers(processedResources);\n * console.log('Available qualifiers:', availableQualifiers);\n * // Output: ['language', 'region', 'platform', 'deviceType']\n *\n * // Use to build dynamic context controls\n * const contextControls = availableQualifiers.map(qualifierName => (\n *   <QualifierContextControl\n *     key={qualifierName}\n *     qualifierName={qualifierName}\n *     value={context[qualifierName]}\n *     onChange={handleContextChange}\n *   />\n * ));\n * ```\n *\n * @example\n * ```typescript\n * // Validate context against available qualifiers\n * function validateResolutionContext(\n *   context: Record<string, string>,\n *   processedResources: ProcessedResources\n * ): string[] {\n *   const availableQualifiers = ResolutionTools.getAvailableQualifiers(processedResources);\n *   const errors: string[] = [];\n *\n *   // Check for unknown qualifiers\n *   Object.keys(context).forEach(key => {\n *     if (!availableQualifiers.includes(key)) {\n *       errors.push(`Unknown qualifier: ${key}`);\n *     }\n *   });\n *\n *   return errors;\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Build qualifier documentation\n * function generateQualifierDocs(processedResources: ProcessedResources) {\n *   const qualifiers = ResolutionTools.getAvailableQualifiers(processedResources);\n *\n *   return qualifiers.map(name => {\n *     const qualifier = processedResources.system.qualifiers.validating.get(name).orThrow();\n *     return {\n *       name,\n *       type: qualifier.type.systemType,\n *       description: `Controls ${name} resolution behavior`\n *     };\n *   });\n * }\n * ```\n *\n * @public\n */\nexport function getAvailableQualifiers(processedResources: ProcessedResources): string[] {\n  if (processedResources.compiledCollection.qualifiers) {\n    return processedResources.compiledCollection.qualifiers.map((q) => q.name);\n  }\n  return [];\n}\n\n/**\n * Check if context has any pending changes by comparing current and pending values.\n *\n * Performs a deep comparison between current context values and pending context values\n * to determine if there are unsaved changes. This is useful for UI state management\n * and preventing data loss in resolution interfaces.\n *\n * @param contextValues - The current/saved context values\n * @param pendingContextValues - The pending/unsaved context values\n * @returns True if there are pending changes, false if contexts are identical\n *\n * @example\n * ```typescript\n * import { ResolutionTools } from '@fgv/ts-res-ui-components';\n *\n * // Check for unsaved context changes in resolution UI\n * const ResolutionInterface = () => {\n *   const [savedContext, setSavedContext] = useState({\n *     language: 'en-US',\n *     platform: 'web'\n *   });\n *\n *   const [pendingContext, setPendingContext] = useState(savedContext);\n *\n *   const hasChanges = ResolutionTools.hasPendingContextChanges(\n *     savedContext,\n *     pendingContext\n *   );\n *\n *   const handleApplyChanges = () => {\n *     if (hasChanges) {\n *       setSavedContext(pendingContext);\n *       // Trigger re-resolution with new context...\n *     }\n *   };\n *\n *   return (\n *     <div>\n *       {hasChanges && (\n *         <div className=\"warning\">\n *           You have unsaved context changes.\n *           <button onClick={handleApplyChanges}>Apply Changes</button>\n *         </div>\n *       )}\n *     </div>\n *   );\n * };\n * ```\n *\n * @example\n * ```typescript\n * // Prevent navigation with unsaved changes\n * function useUnsavedChangesWarning(\n *   currentContext: Record<string, string | undefined>,\n *   pendingContext: Record<string, string | undefined>\n * ) {\n *   const hasChanges = ResolutionTools.hasPendingContextChanges(\n *     currentContext,\n *     pendingContext\n *   );\n *\n *   useEffect(() => {\n *     const handleBeforeUnload = (event: BeforeUnloadEvent) => {\n *       if (hasChanges) {\n *         event.preventDefault();\n *         event.returnValue = 'You have unsaved context changes. Are you sure you want to leave?';\n *       }\n *     };\n *\n *     window.addEventListener('beforeunload', handleBeforeUnload);\n *     return () => window.removeEventListener('beforeunload', handleBeforeUnload);\n *   }, [hasChanges]);\n *\n *   return hasChanges;\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Context change management in resolution workflow\n * class ResolutionContextManager {\n *   private savedContext: Record<string, string | undefined> = {};\n *   private pendingContext: Record<string, string | undefined> = {};\n *\n *   updatePendingValue(qualifier: string, value: string | undefined) {\n *     this.pendingContext = { ...this.pendingContext, [qualifier]: value };\n *   }\n *\n *   hasPendingChanges(): boolean {\n *     return ResolutionTools.hasPendingContextChanges(\n *       this.savedContext,\n *       this.pendingContext\n *     );\n *   }\n *\n *   applyChanges(): boolean {\n *     if (this.hasPendingChanges()) {\n *       this.savedContext = { ...this.pendingContext };\n *       return true; // Changes were applied\n *     }\n *     return false; // No changes to apply\n *   }\n *\n *   discardChanges(): boolean {\n *     if (this.hasPendingChanges()) {\n *       this.pendingContext = { ...this.savedContext };\n *       return true; // Changes were discarded\n *     }\n *     return false; // No changes to discard\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function hasPendingContextChanges(\n  contextValues: Record<string, string | undefined>,\n  pendingContextValues: Record<string, string | undefined>\n): boolean {\n  return JSON.stringify(contextValues) !== JSON.stringify(pendingContextValues);\n}\n"]}