{"version":3,"file":"resolutionEditing.js","sourceRoot":"","sources":["../../src/utils/resolutionEditing.ts"],"names":[],"mappings":"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","sourcesContent":["import { Result, succeed, fail } from '@fgv/ts-utils';\nimport { ConditionSet, ResourceJson, Resources, Runtime } from '@fgv/ts-res';\nimport { Diff } from '@fgv/ts-json';\nimport { JsonObject, isJsonObject } from '@fgv/ts-json-base';\nimport { ProcessedResources, JsonValue } from '../types';\n\nexport interface EditedResourceInfo {\n  resourceId: string;\n  originalValue: JsonValue;\n  editedValue: JsonValue;\n  timestamp: Date;\n}\n\nexport interface EditValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * Validates an edited resource JSON value\n */\nexport function validateEditedResource(editedValue: JsonValue): EditValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Basic JSON validation\n  if (editedValue === null || editedValue === undefined) {\n    errors.push('Resource value cannot be null or undefined');\n  }\n\n  // Check if it's valid JSON-serializable\n  try {\n    JSON.stringify(editedValue);\n  } catch (error) {\n    errors.push(`Invalid JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n\n  // Intentionally minimal validation – structural only. No circular checks.\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n}\n\n/**\n * Computes a 3-way diff between base, resolved, and edited values to create minimal delta\n * @param baseValue - The base/original value before resolution (if available)\n * @param resolvedValue - The fully resolved/composed value shown to user\n * @param editedValue - The value after user edits\n * @returns A minimal delta object with only the changes, or null if no changes\n */\nexport function computeResourceDelta(\n  baseValue: JsonValue | undefined,\n  resolvedValue: JsonValue,\n  editedValue: JsonValue\n): Result<JsonValue> {\n  // Use ts-json's three-way diff for proper delta computation\n  const diffResult = Diff.jsonThreeWayDiff(resolvedValue, editedValue);\n\n  if (diffResult.isFailure()) {\n    // Fall back to full replacement on diff failure\n    console.error('Failed to compute three-way diff:', diffResult.message);\n    return succeed(editedValue);\n  }\n\n  const diff = diffResult.value;\n\n  // If identical, no changes needed\n  if (diff.identical) {\n    return succeed(null);\n  }\n\n  // Build a proper delta that includes deletions as null values\n  const delta: Record<string, JsonValue> = {};\n\n  // Add all changes/additions from onlyInB\n  if (diff.onlyInB !== null) {\n    Object.assign(delta, diff.onlyInB);\n  }\n\n  // Add deletions as null values from onlyInA\n  // onlyInA contains properties that existed in resolved but not in edited\n  if (diff.onlyInA !== null) {\n    // Add null entries for all deleted properties\n    addDeletionsAsNull(diff.onlyInA, delta);\n  }\n\n  // If delta is empty, no changes\n  if (Object.keys(delta).length === 0) {\n    return succeed(null);\n  }\n\n  return succeed(delta);\n}\n\n/**\n * Recursively adds null values to delta for all properties in the deleted object\n */\nfunction addDeletionsAsNull(deleted: JsonValue, delta: Record<string, JsonValue>): void {\n  if (isJsonObject(deleted)) {\n    const deletedObj = deleted as Record<string, JsonValue>;\n    for (const key in deletedObj) {\n      if (deletedObj.hasOwnProperty(key)) {\n        // If this key already exists in delta (from onlyInB), it means the property\n        // was modified, not deleted, so don't override with null\n        if (!(key in delta)) {\n          delta[key] = null;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Creates candidate declarations for edited resources with proper delta handling\n */\nexport function createCandidateDeclarations(\n  editedResources: Map<string, { originalValue: JsonValue; editedValue: JsonValue; delta: JsonValue }>,\n  currentContext: Record<string, string>\n): ResourceJson.Json.ILooseResourceCandidateDecl[] {\n  const declarations: ResourceJson.Json.ILooseResourceCandidateDecl[] = [];\n\n  for (const [resourceId, resourceEdit] of editedResources.entries()) {\n    // Create conditions from current context (using array format)\n    const conditions: ResourceJson.Json.ILooseConditionDecl[] = [];\n\n    for (const [qualifierName, qualifierValue] of Object.entries(currentContext)) {\n      if (qualifierValue && qualifierValue.trim() !== '') {\n        conditions.push({\n          qualifierName,\n          operator: 'matches',\n          value: qualifierValue\n        });\n      }\n    }\n\n    // Always use the delta if we have one (which should be the minimal changes)\n    // The delta will be null if there are no changes, or the delta itself if there are changes\n    const hasChanges = resourceEdit.delta !== null && resourceEdit.delta !== undefined;\n\n    if (!hasChanges) {\n      // No changes, skip this resource\n      continue;\n    }\n\n    // Always save as partial with just the delta when we have changes\n    // This ensures minimal, clean resource files\n    declarations.push({\n      id: resourceId,\n      conditions: conditions.length > 0 ? conditions : undefined,\n      json: resourceEdit.delta as JsonObject, // Always use the delta (minimal changes only)\n      isPartial: true, // Always partial when saving deltas\n      mergeMethod: 'augment' // Always augment to merge the delta with base\n    });\n  }\n\n  return declarations;\n}\n\n/**\n * Converts loose resource declarations (new resources) into loose candidate declarations\n * that can be applied via ResourceManagerBuilder.clone.\n */\nexport function convertLooseResourcesToCandidateDecls(\n  newResources: ReadonlyArray<ResourceJson.Json.ILooseResourceDecl>\n): ResourceJson.Json.ILooseResourceCandidateDecl[] {\n  const candidates: ResourceJson.Json.ILooseResourceCandidateDecl[] = [];\n\n  for (const resource of newResources) {\n    const resourceTypeName = resource.resourceTypeName;\n    // Skip if no candidates defined\n    const childCandidates = resource.candidates ?? [];\n    if (childCandidates.length === 0) {\n      continue;\n    }\n\n    for (const c of childCandidates) {\n      candidates.push({\n        id: resource.id,\n        json: (c.json ?? {}) as JsonObject,\n        conditions: c.conditions,\n        isPartial: c.isPartial ?? false,\n        mergeMethod: c.mergeMethod ?? 'replace',\n        resourceTypeName\n      });\n    }\n  }\n\n  return candidates;\n}\n\n/**\n * Rebuilds the resource system by applying both edit candidates and\n * new resource candidates in a single clone → compile → resolver pass.\n */\nexport async function rebuildSystemWithChanges(\n  originalSystem: ProcessedResources['system'],\n  options: {\n    editedResources?: Map<string, { originalValue: JsonValue; editedValue: JsonValue; delta: JsonValue }>;\n    newResources?: ReadonlyArray<ResourceJson.Json.ILooseResourceDecl>;\n  },\n  currentContext: Record<string, string>\n): Promise<Result<ProcessedResources>> {\n  try {\n    const editCandidates = options.editedResources\n      ? createCandidateDeclarations(options.editedResources, currentContext)\n      : [];\n    const newResourceCandidates = options.newResources\n      ? convertLooseResourcesToCandidateDecls(options.newResources)\n      : [];\n\n    const allCandidates: ReadonlyArray<ResourceJson.Json.ILooseResourceCandidateDecl> = [\n      ...editCandidates,\n      ...newResourceCandidates\n    ];\n\n    return originalSystem.resourceManager\n      .clone({ candidates: allCandidates })\n      .withErrorFormat((message) => `Failed to clone manager: ${message}`)\n      .onSuccess((clonedManager) => {\n        return clonedManager\n          .getCompiledResourceCollection({ includeMetadata: true })\n          .withErrorFormat((message) => `Failed to get compiled collection: ${message}`)\n          .onSuccess((compiledCollection) => {\n            return Runtime.ResourceResolver.create({\n              resourceManager: clonedManager,\n              qualifierTypes: originalSystem.qualifierTypes,\n              contextQualifierProvider: originalSystem.contextQualifierProvider\n            })\n              .withErrorFormat((message) => `Failed to create resolver: ${message}`)\n              .onSuccess((resolver) => {\n                const resourceIds = Array.from(clonedManager.resources.keys());\n                const summary = {\n                  totalResources: resourceIds.length,\n                  resourceIds,\n                  errorCount: 0,\n                  warnings: []\n                };\n\n                const updatedSystem: ProcessedResources = {\n                  system: {\n                    qualifierTypes: originalSystem.qualifierTypes,\n                    qualifiers: originalSystem.qualifiers,\n                    resourceTypes: originalSystem.resourceTypes,\n                    resourceManager: clonedManager,\n                    importManager: originalSystem.importManager,\n                    contextQualifierProvider: originalSystem.contextQualifierProvider\n                  },\n                  compiledCollection,\n                  resolver,\n                  resourceCount: resourceIds.length,\n                  summary\n                };\n\n                return succeed(updatedSystem);\n              });\n          });\n      });\n  } catch (error) {\n    return fail(\n      `Failed to rebuild system with changes: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n\n/**\n * Rebuilds the resource system with edited candidates using deltas\n */\nexport async function rebuildSystemWithEdits(\n  originalSystem: ProcessedResources['system'],\n  editedResources: Map<string, { originalValue: JsonValue; editedValue: JsonValue; delta: JsonValue }>,\n  currentContext: Record<string, string>\n): Promise<Result<ProcessedResources>> {\n  // Delegate to the unified change application helper\n  return rebuildSystemWithChanges(originalSystem, { editedResources }, currentContext);\n}\n\n/**\n * Extracts the current resolution context from resolver state\n */\nexport function extractResolutionContext(\n  resolver: Runtime.ResourceResolver,\n  contextValues: Record<string, string>\n): Record<string, string> {\n  // Filter out empty/undefined context values\n  const cleanContext: Record<string, string> = {};\n\n  for (const [key, value] of Object.entries(contextValues)) {\n    if (value && value.trim() !== '') {\n      cleanContext[key] = value.trim();\n    }\n  }\n\n  return cleanContext;\n}\n\n/**\n * Creates a collision detection key for tracking edit conflicts\n */\nexport function createEditCollisionKey(resourceId: string, context: Record<string, string>): string {\n  const contextEntries = Object.entries(context)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([key, value]) => `${key}=${value}`)\n    .join('&');\n\n  return `${resourceId}?${contextEntries}`;\n}\n\n/**\n * Checks for potential edit conflicts with existing candidates\n */\nexport function checkEditConflicts(\n  resourceManager: Resources.ResourceManagerBuilder | Runtime.IResourceManager,\n  editedResources: Map<string, JsonValue>,\n  currentContext: Record<string, string>\n): { conflicts: string[]; warnings: string[] } {\n  const conflicts: string[] = [];\n  const warnings: string[] = [];\n\n  for (const [resourceId] of editedResources) {\n    try {\n      // Get the current resource to check for conflicts\n      const resourceResult = resourceManager.getBuiltResource(resourceId);\n      if (resourceResult.isSuccess()) {\n        const resource = resourceResult.value;\n\n        // Check if we're likely to create a conflict\n        if (resource.candidates.length > 1) {\n          warnings.push(\n            `Resource ${resourceId} has ${resource.candidates.length} candidates - edits may create conflicts`\n          );\n        }\n\n        // Could add more sophisticated conflict detection here\n        // based on condition overlap analysis\n      }\n    } catch (error) {\n      // Ignore errors in conflict checking\n    }\n  }\n\n  return { conflicts, warnings };\n}\n"]}