{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/types/index.ts"],"names":[],"mappings":";;;AAwmDA,sCAAsC;AACtC,gEAQoC;AAPlC,8HAAA,yBAAyB,OAAA;AACzB,sHAAA,iBAAiB,OAAA;AACjB,iHAAA,YAAY,OAAA;AACZ,iHAAA,YAAY,OAAA;AACZ,4HAAA,uBAAuB,OAAA;AACvB,4HAAA,uBAAuB,OAAA;AACvB,gIAAA,2BAA2B,OAAA","sourcesContent":["import { Result } from '@fgv/ts-utils';\nimport {\n  ResourceJson,\n  Config,\n  Bundle,\n  Resources,\n  Runtime,\n  QualifierTypes,\n  Qualifiers,\n  ResourceTypes,\n  Import\n} from '@fgv/ts-res';\nimport { JsonValue } from '@fgv/ts-json-base';\n\n/**\n * Represents a user-facing message with type classification and timestamp.\n * Used throughout the UI components for displaying feedback to users.\n *\n * @public\n */\nexport interface Message {\n  /** Unique identifier for the message */\n  id: string;\n  /** Classification of the message for UI styling and behavior */\n  type: 'info' | 'warning' | 'error' | 'success';\n  /** The text content of the message */\n  message: string;\n  /** When the message was created */\n  timestamp: Date;\n}\n\n/**\n * Represents the current state of resource filtering.\n * Tracks filter configuration, values, and application state.\n *\n * @public\n */\nexport interface FilterState {\n  /** Whether filtering is currently enabled */\n  enabled: boolean;\n  /** Current filter values being edited (not yet applied) */\n  values: Record<string, string | undefined>;\n  /** Filter values that have been applied to the resource manager */\n  appliedValues: Record<string, string | undefined>;\n  /** Whether there are unsaved changes in the filter values */\n  hasPendingChanges: boolean;\n  /** Whether to reduce qualifiers when filtering (removes unused qualifier dimensions) */\n  reduceQualifiers: boolean;\n}\n\n/**\n * Actions available for managing filter state.\n * Provides methods for updating all aspects of resource filtering.\n *\n * @public\n */\nexport interface FilterActions {\n  /** Enable or disable filtering */\n  updateFilterEnabled: (enabled: boolean) => void;\n  /** Update filter values (does not apply them until applyFilterValues is called) */\n  updateFilterValues: (values: Record<string, string | undefined>) => void;\n  /** Apply current filter values to create a filtered resource manager */\n  applyFilterValues: () => void;\n  /** Reset filter values to their applied state (discards pending changes) */\n  resetFilterValues: () => void;\n  /** Enable or disable qualifier reduction during filtering */\n  updateReduceQualifiers: (reduceQualifiers: boolean) => void;\n}\n\n/**\n * Represents a fully processed ts-res system ready for use.\n * Contains both the runtime system components and the compiled resource collection.\n * This is the primary data structure used by all UI components.\n *\n * @public\n */\nexport interface ProcessedResources {\n  /** Core ts-res system components */\n  system: {\n    /** Primary resource manager for building and managing resources */\n    resourceManager: Resources.ResourceManagerBuilder;\n    /** Collection of qualifier type definitions */\n    qualifierTypes: QualifierTypes.ReadOnlyQualifierTypeCollector;\n    /** Collection of qualifier declarations */\n    qualifiers: Qualifiers.IReadOnlyQualifierCollector;\n    /** Collection of resource type definitions */\n    resourceTypes: ResourceTypes.ReadOnlyResourceTypeCollector;\n    /** Manager for handling resource imports */\n    importManager: Import.ImportManager;\n    /** Provider for validating and managing runtime context */\n    contextQualifierProvider: Runtime.ValidatingSimpleContextQualifierProvider;\n  };\n  /** Compiled version of the resource collection for efficient resolution */\n  compiledCollection: ResourceJson.Compiled.ICompiledResourceCollection;\n  /** Resource resolver for runtime resource resolution */\n  resolver: Runtime.ResourceResolver;\n  /** Total count of resources in the system */\n  resourceCount: number;\n  /** Summary information about the resource system */\n  summary: {\n    /** Total number of resources */\n    totalResources: number;\n    /** Array of all resource identifiers */\n    resourceIds: string[];\n    /** Number of errors encountered during processing */\n    errorCount: number;\n    /** Array of warning messages from processing */\n    warnings: string[];\n  };\n}\n\n/**\n * Extended processed resources with additional metadata and context.\n * Includes information about source configuration and bundle loading.\n *\n * @public\n */\nexport interface ExtendedProcessedResources extends ProcessedResources {\n  /** The configuration used to create this resource system */\n  activeConfiguration?: Config.Model.ISystemConfiguration | null;\n  /** Whether this system was loaded from a bundle file */\n  isLoadedFromBundle?: boolean;\n  /** Metadata from the bundle file, if loaded from bundle */\n  bundleMetadata?: Bundle.IBundleMetadata | null;\n}\n\n/**\n * Represents the current state of the resource manager.\n * Tracks processing status, data, and any errors.\n *\n * @public\n */\nexport interface ResourceManagerState {\n  /** Whether the system is currently processing resources */\n  isProcessing: boolean;\n  /** The processed resource system, or null if not yet processed */\n  processedResources: ExtendedProcessedResources | null;\n  /** Current error message, or null if no error */\n  error: string | null;\n  /** Whether any resource data has been successfully processed */\n  hasProcessedData: boolean;\n  /** The active system configuration */\n  activeConfiguration: Config.Model.ISystemConfiguration | null;\n  /** Whether the current data was loaded from a bundle */\n  isLoadedFromBundle: boolean;\n  /** Bundle metadata if loaded from bundle */\n  bundleMetadata: Bundle.IBundleMetadata | null;\n}\n\n/**\n * Represents a file imported into the system.\n * Used for handling individual resource files and configurations.\n *\n * @public\n */\nexport interface ImportedFile {\n  /** Name of the file */\n  name: string;\n  /** Optional file path within the import structure */\n  path?: string;\n  /** Text content of the file */\n  content: string;\n  /** MIME type or file type identifier */\n  type?: string;\n}\n\n/**\n * Represents a directory structure imported into the system.\n * Supports nested directory hierarchies with files and subdirectories.\n *\n * @public\n */\nexport interface ImportedDirectory {\n  /** Name of the directory */\n  name: string;\n  /** Optional directory path within the import structure */\n  path?: string;\n  /** Files contained in this directory */\n  files: ImportedFile[];\n  /** Nested subdirectories */\n  subdirectories?: ImportedDirectory[];\n}\n\n/**\n * Base properties shared by all view components.\n * Provides common functionality for messaging and styling.\n *\n * @public\n */\nexport interface ViewBaseProps {\n  /** Callback for displaying messages to the user */\n  onMessage?: (type: Message['type'], message: string) => void;\n  /** Additional CSS class names for styling */\n  className?: string;\n  /** How to present the ResourcePicker options control (default: 'hidden' for production use) */\n  pickerOptionsPresentation?: 'hidden' | 'inline' | 'collapsible' | 'popup' | 'popover';\n}\n\n/**\n * Props for the ImportView component.\n * Handles importing resource configurations and bundles.\n *\n * @public\n */\nexport interface ImportViewProps extends ViewBaseProps {\n  /** Callback when resource files/directories are imported */\n  onImport?: (data: ImportedDirectory | ImportedFile[]) => void;\n  /** Callback when a bundle file is imported */\n  onBundleImport?: (bundle: Bundle.IBundle) => void;\n  /** Callback when a ZIP file is imported with optional configuration */\n  onZipImport?: (\n    zipData: ImportedDirectory | ImportedFile[],\n    config?: Config.Model.ISystemConfiguration\n  ) => void;\n  /** File types accepted for import */\n  acceptedFileTypes?: string[];\n  /** External error state to override local import status */\n  importError?: string | null;\n}\n\n/**\n * Props for the SourceView component.\n * Displays and manages the source resource collection.\n *\n * @public\n */\nexport interface SourceViewProps extends ViewBaseProps {\n  /** The processed resource system to display */\n  resources?: ExtendedProcessedResources | null;\n  /** Currently selected resource ID for detailed view */\n  selectedResourceId?: string | null;\n  /** Callback when a resource is selected */\n  onResourceSelect?: (resourceId: string) => void;\n  /** Callback when exporting resource collection data */\n  onExport?: (data: unknown, type: 'json') => void;\n  /** Optional configuration for the ResourcePicker behavior */\n  pickerOptions?: import('../components/pickers/ResourcePicker/types').ResourcePickerOptions;\n}\n\n/**\n * Props for the FilterView component.\n * Provides resource filtering functionality.\n *\n * @public\n */\nexport interface FilterViewProps extends ViewBaseProps {\n  /** The resource system to filter */\n  resources?: ProcessedResources | null;\n  /** Current state of the filter configuration */\n  filterState: FilterState;\n  /** Actions for managing filter state */\n  filterActions: FilterActions;\n  /** Result of applying the filter */\n  filterResult?: FilterResult | null;\n  /** Callback when filter results change */\n  onFilterResult?: (result: FilterResult | null) => void;\n  /** Optional configuration for the ResourcePicker behavior */\n  pickerOptions?: import('../components/pickers/ResourcePicker/types').ResourcePickerOptions;\n  /** Optional configuration for context control behavior */\n  contextOptions?: ResolutionContextOptions;\n}\n\n/**\n * Props for the CompiledView component.\n * Displays the compiled resource collection structure.\n *\n * @public\n */\nexport interface CompiledViewProps extends ViewBaseProps {\n  /** The resource system to display */\n  resources?: ExtendedProcessedResources | null;\n  /** Optional filter state for filtered views */\n  filterState?: FilterState;\n  /** Result of filtering if applied */\n  filterResult?: FilterResult | null;\n  /** Whether to use normalization in display */\n  useNormalization?: boolean;\n  /** Callback for exporting compiled data or bundles */\n  onExport?: (\n    data: ResourceJson.Compiled.ICompiledResourceCollection | Bundle.IBundle,\n    type: 'json' | 'bundle'\n  ) => void;\n  /** Optional configuration for the ResourcePicker behavior */\n  pickerOptions?: import('../components/pickers/ResourcePicker/types').ResourcePickerOptions;\n}\n\n/**\n * Result of attempting to create a resource editor for a specific resource.\n * Used by ResourceEditorFactory to provide type-specific editors.\n *\n * @public\n */\nexport type ResourceEditorResult =\n  | {\n      /** Indicates whether the factory was able to create an editor for the resource */\n      success: true;\n      /** The React component to render for editing this resource */\n      editor: React.ComponentType<ResourceEditorProps>;\n    }\n  | {\n      /** Indicates the factory could not create an editor for this resource */\n      success: false;\n      /** Optional message explaining why no editor could be created */\n      message?: string;\n    };\n\n/**\n * Props that will be passed to custom resource editors created by ResourceEditorFactory.\n * Custom editors should implement this interface to be compatible with ResolutionView.\n *\n * @public\n */\nexport interface ResourceEditorProps {\n  /** The original JSON value to edit */\n  value: any;\n  /** The resource ID for tracking edits */\n  resourceId: string;\n  /** Whether this resource has been edited */\n  isEdited?: boolean;\n  /** The current edited value if any */\n  editedValue?: any;\n  /** Callback when the user saves an edit */\n  onSave?: (resourceId: string, editedValue: any, originalValue: any) => void;\n  /** Callback when the user cancels an edit */\n  onCancel?: (resourceId: string) => void;\n  /** Whether editing is currently disabled */\n  disabled?: boolean;\n  /** Additional CSS classes */\n  className?: string;\n}\n\n/**\n * Factory interface for creating type-specific resource editors.\n * Allows ResolutionView to provide custom editing experiences for different resource types.\n *\n * @public\n */\nexport interface ResourceEditorFactory {\n  /**\n   * Attempts to create a resource editor for the given resource.\n   *\n   * @param resourceId - The ID of the resource to edit\n   * @param resourceType - The type/key of the resource\n   * @param value - The current value of the resource\n   * @returns ResourceEditorResult indicating success/failure and the editor component or error message\n   */\n  createEditor(resourceId: string, resourceType: string, value: any): ResourceEditorResult;\n}\n\n/**\n * Props for the ResolutionView component.\n * Provides resource resolution testing and debugging.\n *\n * @public\n */\nexport interface ResolutionViewProps extends ViewBaseProps {\n  /** The resource system for resolution testing */\n  resources?: ProcessedResources | null;\n  /** Optional filter state */\n  filterState?: FilterState;\n  /** Filter results if applied */\n  filterResult?: FilterResult | null;\n  /** Current resolution testing state */\n  resolutionState?: ResolutionState;\n  /** Actions for managing resolution state */\n  resolutionActions?: ResolutionActions;\n  /** Available qualifiers for context building */\n  availableQualifiers?: string[];\n  /** Optional factory for creating type-specific resource editors */\n  resourceEditorFactory?: ResourceEditorFactory;\n  /** Optional configuration for the ResourcePicker behavior */\n  pickerOptions?: import('../components/pickers/ResourcePicker/types').ResourcePickerOptions;\n  /** Optional configuration for the resolution context controls */\n  contextOptions?: ResolutionContextOptions;\n  /** Lock to a single view state and suppress the view state selector */\n  lockedViewMode?: 'composed' | 'best' | 'all' | 'raw';\n  /** Custom titles for the main sections */\n  sectionTitles?: {\n    /** Title for the resources picker section (default: \"Resources\") */\n    resources?: string;\n    /** Title for the results section (default: \"Results\") */\n    results?: string;\n  };\n  /** Allow creating new resources in the UI */\n  allowResourceCreation?: boolean;\n  /** Default resource type for new resources (hides type selector if provided) */\n  defaultResourceType?: string;\n  /** Factory for creating custom resource types */\n  resourceTypeFactory?: ResourceTypes.IResourceType[];\n  /** Callback when pending resources are applied */\n  onPendingResourcesApplied?: (added: ResourceJson.Json.ILooseResourceDecl[], deleted: string[]) => void;\n  /** Show pending resources in the resource list with visual distinction */\n  showPendingResourcesInList?: boolean;\n}\n\n/**\n * Information about a resource being edited in the resolution view.\n * Tracks changes to resource values and states.\n *\n * @public\n */\nexport interface EditedResourceInfo {\n  /** Unique identifier of the resource being edited */\n  resourceId: string;\n  originalValue: JsonValue;\n  editedValue: JsonValue;\n  timestamp: Date;\n}\n\n// Resolution types\n/**\n * Current state of resource resolution testing and debugging.\n * Tracks context values, resolution results, and editing state.\n *\n * @public\n */\nexport interface ResolutionState {\n  /** Current context values applied for resolution */\n  contextValues: Record<string, string | undefined>;\n  /** Context values being edited but not yet applied */\n  pendingContextValues: Record<string, string | undefined>;\n  /** ID of the currently selected resource for resolution testing */\n  selectedResourceId: string | null;\n  /** The resolver instance being used for testing */\n  currentResolver: Runtime.ResourceResolver | null;\n  /** Result of the most recent resolution attempt */\n  resolutionResult: ResolutionResult | null;\n  /** Current view mode for displaying resolution results */\n  viewMode: 'composed' | 'best' | 'all' | 'raw';\n  /** Whether there are pending context changes not yet applied */\n  hasPendingChanges: boolean;\n  /** Map of resource IDs to their edited values */\n  editedResources: Map<string, JsonValue>;\n  /** Whether there are unsaved resource edits */\n  hasUnsavedEdits: boolean;\n  /** Whether edits are currently being applied to the system */\n  isApplyingEdits: boolean;\n  /** Resources waiting to be added to the system */\n  pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;\n  /** IDs of resources marked for deletion */\n  pendingResourceDeletions: Set<string>;\n  /** Draft of a new resource being created */\n  newResourceDraft?: {\n    resourceId: string;\n    resourceType: string;\n    template: ResourceJson.Json.ILooseResourceDecl;\n    isValid: boolean;\n  };\n  /** Available resource types for creation */\n  availableResourceTypes: ResourceTypes.IResourceType[];\n  /** Whether there are pending resource additions or deletions */\n  hasPendingResourceChanges: boolean;\n}\n\n/**\n * Parameters for creating a pending resource atomically.\n *\n * @example\n * ```typescript\n * const params: CreatePendingResourceParams = {\n *   id: 'platform.languages.az-AZ',\n *   resourceTypeName: 'json',\n *   json: { text: 'Welcome', locale: 'az-AZ' }\n * };\n * ```\n *\n * @public\n */\nexport interface CreatePendingResourceParams {\n  /** Full resource ID (e.g., 'platform.languages.az-AZ') - must be unique */\n  id: string;\n  /** Name of the resource type to use for validation and template creation */\n  resourceTypeName: string;\n  /** JSON content for the resource candidate. If undefined, the resource type's base template will be used. */\n  json?: JsonValue;\n}\n\n/**\n * Parameters for starting a new resource with optional pre-seeding.\n *\n * @example\n * ```typescript\n * // Basic start with just type\n * const basicParams: StartNewResourceParams = {\n *   defaultTypeName: 'json'\n * };\n *\n * // Pre-seeded start with full data\n * const preSeededParams: StartNewResourceParams = {\n *   id: 'user.welcome',\n *   resourceTypeName: 'json',\n *   json: { text: 'Welcome!' }\n * };\n * ```\n *\n * @public\n */\nexport interface StartNewResourceParams {\n  /** Resource type to use (optional - will use first available if not provided) */\n  defaultTypeName?: string;\n  /** Pre-seed with specific ID (optional) */\n  id?: string;\n  /** Pre-seed with specific resource type name (optional) */\n  resourceTypeName?: string;\n  /** Pre-seed with specific JSON content (optional) */\n  json?: JsonValue;\n}\n\n/**\n * Actions available for managing resource resolution testing and editing.\n * Provides methods for context management, resource selection, and value editing.\n *\n * @public\n */\nexport interface ResolutionActions {\n  /** Update a context value for resolution testing */\n  updateContextValue: (qualifierName: string, value: string | undefined) => Result<void>;\n  /** Apply pending context changes to the resolver (with optional host-managed values) */\n  applyContext: (hostManagedValues?: Record<string, string | undefined>) => Result<void>;\n  /** Select a resource for detailed resolution testing */\n  selectResource: (resourceId: string) => Result<void>;\n  /** Change how resolution results are displayed */\n  setViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;\n  /** Clear the resolution cache to force fresh resolution */\n  resetCache: () => Result<void>;\n  /** Save an edit to a resource value */\n  saveEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => Result<void>;\n  /** Get the edited value for a resource, if any */\n  getEditedValue: (resourceId: string) => JsonValue | undefined;\n  /** Check if a resource has been edited */\n  hasEdit: (resourceId: string) => boolean;\n  /** Clear all pending edits */\n  clearEdits: () => Result<{ clearedCount: number }>;\n  /** Discard all pending edits */\n  discardEdits: () => Result<{ discardedCount: number }>;\n\n  // Enhanced resource creation actions with Result pattern return values\n  /** Create a pending resource atomically with validation */\n  createPendingResource: (params: CreatePendingResourceParams) => Result<void>;\n  /** Start creating a new resource (enhanced with optional pre-seeding) */\n  startNewResource: (\n    params?: StartNewResourceParams\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  /** Update the resource ID for the new resource being created */\n  updateNewResourceId: (\n    id: string\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  /** Select a resource type for the new resource */\n  selectResourceType: (\n    type: string\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  /** Update the JSON content for the new resource being created */\n  updateNewResourceJson: (\n    json: JsonValue\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  /** Add the new resource to pending resources (not applied yet) */\n  saveNewResourceAsPending: () => Result<{\n    pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;\n    diagnostics: string[];\n  }>;\n  /** Cancel the new resource creation */\n  cancelNewResource: () => void;\n  /** Remove a pending resource */\n  removePendingResource: (resourceId: string) => Result<void>;\n  /** Mark an existing resource for deletion */\n  markResourceForDeletion: (resourceId: string) => void;\n  /** Apply all pending resource additions and deletions */\n  applyPendingResources: () => Promise<\n    Result<{\n      appliedCount: number;\n      existingResourceEditCount: number;\n      pendingResourceEditCount: number;\n      newResourceCount: number;\n      deletionCount: number;\n    }>\n  >;\n  /** Discard all pending resource changes */\n  discardPendingResources: () => void;\n}\n\n/**\n * Options for controlling individual qualifier context controls.\n *\n * Provides fine-grained control over the behavior, appearance, and editability\n * of individual qualifier inputs. This allows hosts to customize which qualifiers\n * are editable, provide external values, and control the presentation.\n *\n * @example\n * ```tsx\n * // Make a qualifier readonly with external value\n * const languageOptions: QualifierControlOptions = {\n *   visible: true,\n *   editable: false,\n *   hostValue: 'en-US',\n *   showHostValue: true,\n *   placeholder: 'Language managed externally'\n * };\n * ```\n *\n * @public\n */\nexport interface QualifierControlOptions {\n  /** Whether this qualifier should be visible at all */\n  visible?: boolean;\n  /** Whether this qualifier is editable by the user */\n  editable?: boolean;\n  /** External/host-managed value that overrides user input */\n  hostValue?: string | undefined;\n  /** Whether to show host-managed values in the display */\n  showHostValue?: boolean;\n  /** Custom placeholder text for this qualifier */\n  placeholder?: string;\n  /** Custom CSS classes for this qualifier control */\n  className?: string;\n}\n\n/**\n * Configuration options for the resolution context controls in ResolutionView.\n *\n * Controls the visibility and behavior of the context configuration panel,\n * allowing hosts to customize which qualifiers are editable and provide\n * externally managed context values. Uses QualifierControlOptions for\n * per-qualifier customization.\n *\n * @example\n * ```tsx\n * // Hide context UI entirely - host controls context externally\n * <ResolutionView\n *   contextOptions={{ showContextControls: false }}\n *   // ... other props\n * />\n *\n * // Fine-grained qualifier control\n * <ResolutionView\n *   contextOptions={{\n *     showContextControls: true,\n *     qualifierOptions: {\n *       language: { editable: true, placeholder: 'Select language...' },\n *       platform: { editable: false, hostValue: 'web', showHostValue: true },\n *       env: { visible: false } // Hidden from UI entirely\n *     },\n *     hostManagedValues: { env: 'production' } // Invisible but active\n *   }}\n *   // ... other props\n * />\n * ```\n *\n * @public\n */\nexport interface ResolutionContextOptions {\n  /** Visibility options */\n  /** Whether to show the context configuration panel at all */\n  showContextControls?: boolean;\n  /** Whether to show the current context display */\n  showCurrentContext?: boolean;\n  /** Whether to show the Apply/Reset buttons */\n  showContextActions?: boolean;\n\n  /** Per-qualifier control options */\n  qualifierOptions?: Record<string, QualifierControlOptions>;\n\n  /** Global defaults for qualifiers not specifically configured */\n  defaultQualifierEditable?: boolean;\n  defaultQualifierVisible?: boolean;\n\n  /** Host-managed values that override all user input for invisible qualifiers */\n  hostManagedValues?: Record<string, string | undefined>;\n\n  /** Appearance options */\n  /** Custom title for the context configuration panel */\n  contextPanelTitle?: string;\n  /** Global placeholder text pattern for qualifier inputs */\n  globalPlaceholder?: string | ((qualifierName: string) => string);\n  /** Additional CSS classes for the context panel */\n  contextPanelClassName?: string;\n}\n\n/**\n * Result of attempting to resolve a specific resource with a given context.\n * Contains the resolved value, matching candidates, and diagnostic information.\n *\n * @public\n */\nexport interface ResolutionResult {\n  /** Whether the resolution was successful */\n  success: boolean;\n  /** ID of the resource that was resolved */\n  resourceId: string;\n  /** The resolved resource object, if successful */\n  resource?: Runtime.IResource;\n  /** The best matching candidate for this context */\n  bestCandidate?: Runtime.IResourceCandidate;\n  /** All candidates that were considered during resolution */\n  allCandidates?: readonly Runtime.IResourceCandidate[];\n  /** Detailed information about each candidate's matching process */\n  candidateDetails?: CandidateInfo[];\n  /** The final composed/resolved value */\n  composedValue?: JsonValue;\n  /** Error message if resolution failed */\n  error?: string;\n}\n\n/**\n * Detailed information about how a resource candidate was evaluated during resolution.\n * Provides diagnostic data for understanding why candidates matched or didn't match.\n *\n * @public\n */\nexport interface CandidateInfo {\n  /** The candidate that was evaluated */\n  candidate: Runtime.IResourceCandidate;\n  /** Key identifying the condition set used for evaluation */\n  conditionSetKey: string | null;\n  /** Index of this candidate within the resource */\n  candidateIndex: number;\n  /** Whether this candidate matched the resolution context */\n  matched: boolean;\n  /** Type of match that occurred */\n  matchType: 'match' | 'matchAsDefault' | 'noMatch';\n  /** Whether this was a default match (fallback when no exact match) */\n  isDefaultMatch: boolean;\n  /** Detailed evaluation results for each condition */\n  conditionEvaluations?: ConditionEvaluationResult[];\n}\n\n/**\n * Result of evaluating a single condition during resource resolution.\n * Shows how a specific qualifier value compared against a condition.\n *\n * @public\n */\nexport interface ConditionEvaluationResult {\n  /** Name of the qualifier being evaluated */\n  qualifierName: string;\n  /** Value of the qualifier in the resolution context */\n  qualifierValue: string | undefined;\n  /** Value specified in the resource condition */\n  conditionValue: string | undefined;\n  /** Comparison operator used for evaluation */\n  operator: string;\n  /** Numeric score for this condition evaluation */\n  score: number;\n  /** Whether this condition matched */\n  matched: boolean;\n  /** Type of match that occurred */\n  matchType: 'match' | 'matchAsDefault' | 'noMatch';\n  /** Score when used as a default match */\n  scoreAsDefault?: number;\n  /** Index of this condition within the candidate */\n  conditionIndex: number;\n}\n\n/**\n * Props for the ConfigurationView component.\n * Handles editing and managing system configuration including qualifiers, qualifier types, and resource types.\n *\n * @public\n */\nexport interface ConfigurationViewProps extends ViewBaseProps {\n  /** Current system configuration to display and edit */\n  configuration?: Config.Model.ISystemConfiguration | null;\n  /** Callback when configuration changes (during editing) */\n  onConfigurationChange?: (config: Config.Model.ISystemConfiguration) => void;\n  /** Callback when configuration should be saved/applied */\n  onSave?: (config: Config.Model.ISystemConfiguration) => void;\n  /** Whether there are unsaved changes to the configuration */\n  hasUnsavedChanges?: boolean;\n}\n\n// Resource detail types for SourceView\n/**\n * Detailed information about a resource for display in source views.\n * Contains the resource structure including all candidates and their conditions.\n *\n * @public\n */\nexport interface ResourceDetailData {\n  /** Unique identifier of the resource */\n  id: string;\n  /** Type classification of the resource */\n  resourceType: string;\n  /** Total number of candidates defined for this resource */\n  candidateCount: number;\n  /** Array of all candidates with their conditions and values */\n  candidates: Array<{\n    /** The JSON value for this candidate */\n    json: JsonValue;\n    /** Conditions that determine when this candidate is selected */\n    conditions: Array<{\n      /** Name of the qualifier this condition evaluates */\n      qualifier: string;\n      /** Comparison operator for the condition */\n      operator: string;\n      /** Value to compare against */\n      value: string;\n      /** Priority/precedence of this condition */\n      priority: number;\n      /** Score when used as a default match */\n      scoreAsDefault?: number;\n    }>;\n    /** Whether this candidate provides partial data that will be merged */\n    isPartial: boolean;\n    /** Method used to merge this candidate with others */\n    mergeMethod: string;\n  }>;\n}\n\n/**\n * Information about a single resource after filtering has been applied.\n *\n * FilteredResource provides detailed analytics about how filtering affected\n * an individual resource, including candidate count changes and potential\n * issues detected during the filtering process. This information is essential\n * for understanding filtering effectiveness and diagnosing filtering problems.\n *\n * @example\n * ```typescript\n * import { FilterTools } from '@fgv/ts-res-ui-components';\n *\n * // Analyze filter results for resources\n * const filterResult = await FilterTools.createFilteredResourceManagerSimple(\n *   processedResources,\n *   { language: 'en-US', platform: 'web' }\n * );\n *\n * if (filterResult.isSuccess() && filterResult.value.success) {\n *   filterResult.value.filteredResources.forEach((resource: FilteredResource) => {\n *     console.log(`Resource ${resource.id}:`);\n *     console.log(`  Original candidates: ${resource.originalCandidateCount}`);\n *     console.log(`  Filtered candidates: ${resource.filteredCandidateCount}`);\n *\n *     if (resource.hasWarning) {\n *       console.warn(`  ⚠️  Warning: Potential filtering issue detected`);\n *     }\n *\n *     const reductionPercent = Math.round(\n *       ((resource.originalCandidateCount - resource.filteredCandidateCount) /\n *        resource.originalCandidateCount) * 100\n *     );\n *     console.log(`  Reduction: ${reductionPercent}%`);\n *   });\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Use FilteredResource data in UI components\n * function FilterResultsSummary({ filteredResources }: { filteredResources: FilteredResource[] }) {\n *   const totalOriginal = filteredResources.reduce((sum, r) => sum + r.originalCandidateCount, 0);\n *   const totalFiltered = filteredResources.reduce((sum, r) => sum + r.filteredCandidateCount, 0);\n *   const warningCount = filteredResources.filter(r => r.hasWarning).length;\n *\n *   return (\n *     <div className=\"filter-summary\">\n *       <h3>Filter Results Summary</h3>\n *       <div className=\"stats\">\n *         <div>Resources: {filteredResources.length}</div>\n *         <div>Total candidates: {totalOriginal} → {totalFiltered}</div>\n *         <div>Reduction: {Math.round(((totalOriginal - totalFiltered) / totalOriginal) * 100)}%</div>\n *         {warningCount > 0 && (\n *           <div className=\"warnings\">⚠️ {warningCount} resource(s) with warnings</div>\n *         )}\n *       </div>\n *\n *       <div className=\"resource-list\">\n *         {filteredResources.map(resource => (\n *           <div key={resource.id} className={resource.hasWarning ? 'has-warning' : ''}>\n *             <span className=\"resource-id\">{resource.id}</span>\n *             <span className=\"candidate-counts\">\n *               {resource.originalCandidateCount} → {resource.filteredCandidateCount}\n *             </span>\n *             {resource.hasWarning && <span className=\"warning-icon\">⚠️</span>}\n *           </div>\n *         ))}\n *       </div>\n *     </div>\n *   );\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Filter resources by specific criteria\n * function analyzeFilteredResources(filteredResources: FilteredResource[]) {\n *   // Find resources that were completely filtered out\n *   const completelyFiltered = filteredResources.filter(r =>\n *     r.filteredCandidateCount === 0 && r.originalCandidateCount > 0\n *   );\n *\n *   // Find resources with significant candidate reduction\n *   const significantReduction = filteredResources.filter(r => {\n *     const reductionPercent = (r.originalCandidateCount - r.filteredCandidateCount) / r.originalCandidateCount;\n *     return reductionPercent > 0.5; // More than 50% reduction\n *   });\n *\n *   // Find resources with warnings\n *   const withWarnings = filteredResources.filter(r => r.hasWarning);\n *\n *   return {\n *     completelyFiltered: completelyFiltered.map(r => r.id),\n *     significantReduction: significantReduction.map(r => ({\n *       id: r.id,\n *       reductionPercent: Math.round(\n *         ((r.originalCandidateCount - r.filteredCandidateCount) / r.originalCandidateCount) * 100\n *       )\n *     })),\n *     withWarnings: withWarnings.map(r => r.id),\n *     totalResources: filteredResources.length\n *   };\n * }\n * ```\n *\n * @public\n */\nexport interface FilteredResource {\n  /** The resource ID that was filtered */\n  id: string;\n  /** Number of candidates before filtering was applied */\n  originalCandidateCount: number;\n  /** Number of candidates remaining after filtering */\n  filteredCandidateCount: number;\n  /** Whether this resource has potential filtering issues or warnings */\n  hasWarning: boolean;\n}\n\n/**\n * Complete result of a filtering operation including processed data and analysis.\n *\n * FilterResult encapsulates the outcome of applying resource filtering, providing\n * both the filtered resource system and detailed analytics about the filtering\n * process. It includes success/failure status, processed resources, per-resource\n * analysis, and any warnings or errors encountered during filtering.\n *\n * @example\n * ```typescript\n * import { FilterTools } from '@fgv/ts-res-ui-components';\n *\n * // Apply filtering and handle results\n * async function applyResourceFilter(\n *   processedResources: ProcessedResources,\n *   context: Record<string, string>\n * ) {\n *   const result = await FilterTools.createFilteredResourceManagerSimple(\n *     processedResources,\n *     context,\n *     { partialContextMatch: true, enableDebugLogging: false }\n *   );\n *\n *   if (result.isSuccess()) {\n *     const filterResult: FilterResult = result.value;\n *\n *     if (filterResult.success) {\n *       console.log('Filter applied successfully!');\n *       console.log(`Processed ${filterResult.filteredResources.length} resources`);\n *\n *       // Use the filtered resource system\n *       if (filterResult.processedResources) {\n *         console.log('Filtered resource system ready for use');\n *         return filterResult.processedResources;\n *       }\n *\n *       // Check for warnings\n *       if (filterResult.warnings.length > 0) {\n *         filterResult.warnings.forEach(warning => {\n *           console.warn(`⚠️ Filter warning: ${warning}`);\n *         });\n *       }\n *     } else {\n *       console.error(`Filter failed: ${filterResult.error}`);\n *     }\n *   } else {\n *     console.error(`Filter operation failed: ${result.message}`);\n *   }\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Use FilterResult in React component for filter management\n * function FilterResultsPanel({ filterResult }: { filterResult: FilterResult | null }) {\n *   if (!filterResult) {\n *     return <div className=\"no-filter\">No filter applied</div>;\n *   }\n *\n *   if (!filterResult.success) {\n *     return (\n *       <div className=\"filter-error\">\n *         <h3>Filter Error</h3>\n *         <p>{filterResult.error}</p>\n *       </div>\n *     );\n *   }\n *\n *   const stats = filterResult.filteredResources;\n *   const totalOriginal = stats.reduce((sum, r) => sum + r.originalCandidateCount, 0);\n *   const totalFiltered = stats.reduce((sum, r) => sum + r.filteredCandidateCount, 0);\n *   const resourcesWithWarnings = stats.filter(r => r.hasWarning).length;\n *\n *   return (\n *     <div className=\"filter-results\">\n *       <h3>Filter Results</h3>\n *\n *       <div className=\"summary\">\n *         <div className=\"stat\">\n *           <label>Resources Processed:</label>\n *           <span>{stats.length}</span>\n *         </div>\n *         <div className=\"stat\">\n *           <label>Total Candidates:</label>\n *           <span>{totalOriginal} → {totalFiltered}</span>\n *         </div>\n *         <div className=\"stat\">\n *           <label>Reduction:</label>\n *           <span>{Math.round(((totalOriginal - totalFiltered) / totalOriginal) * 100)}%</span>\n *         </div>\n *       </div>\n *\n *       {filterResult.warnings.length > 0 && (\n *         <div className=\"warnings\">\n *           <h4>Warnings ({filterResult.warnings.length})</h4>\n *           <ul>\n *             {filterResult.warnings.map((warning, index) => (\n *               <li key={index} className=\"warning\">{warning}</li>\n *             ))}\n *           </ul>\n *         </div>\n *       )}\n *\n *       {resourcesWithWarnings > 0 && (\n *         <div className=\"resource-warnings\">\n *           <h4>Resources with Issues ({resourcesWithWarnings})</h4>\n *           <ul>\n *             {stats.filter(r => r.hasWarning).map(resource => (\n *               <li key={resource.id} className=\"resource-warning\">\n *                 {resource.id} - {resource.filteredCandidateCount}/{resource.originalCandidateCount} candidates\n *               </li>\n *             ))}\n *           </ul>\n *         </div>\n *       )}\n *     </div>\n *   );\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Advanced filter result analysis and validation\n * function validateFilterResults(filterResult: FilterResult): {\n *   isValid: boolean;\n *   issues: string[];\n *   recommendations: string[];\n * } {\n *   const issues: string[] = [];\n *   const recommendations: string[] = [];\n *\n *   if (!filterResult.success) {\n *     issues.push(`Filter operation failed: ${filterResult.error}`);\n *     recommendations.push('Check filter configuration and resource data');\n *     return { isValid: false, issues, recommendations };\n *   }\n *\n *   const resources = filterResult.filteredResources;\n *\n *   // Check for completely filtered resources\n *   const completelyFiltered = resources.filter(r =>\n *     r.filteredCandidateCount === 0 && r.originalCandidateCount > 0\n *   );\n *\n *   if (completelyFiltered.length > 0) {\n *     issues.push(`${completelyFiltered.length} resource(s) have no candidates after filtering`);\n *     recommendations.push('Consider using partial context matching or reviewing filter criteria');\n *   }\n *\n *   // Check for excessive warnings\n *   const warningCount = filterResult.warnings.length;\n *   if (warningCount > resources.length * 0.1) { // More than 10% warning rate\n *     issues.push(`High warning rate: ${warningCount} warnings for ${resources.length} resources`);\n *     recommendations.push('Review resource configuration and filter parameters');\n *   }\n *\n *   // Check for minimal filtering effect\n *   const totalOriginal = resources.reduce((sum, r) => sum + r.originalCandidateCount, 0);\n *   const totalFiltered = resources.reduce((sum, r) => sum + r.filteredCandidateCount, 0);\n *   const reductionPercent = ((totalOriginal - totalFiltered) / totalOriginal) * 100;\n *\n *   if (reductionPercent < 5) { // Less than 5% reduction\n *     issues.push(`Filter had minimal effect: only ${reductionPercent.toFixed(1)}% candidate reduction`);\n *     recommendations.push('Consider more specific filter criteria or check if filtering is needed');\n *   }\n *\n *   return {\n *     isValid: issues.length === 0,\n *     issues,\n *     recommendations\n *   };\n * }\n * ```\n *\n * @public\n */\nexport interface FilterResult {\n  /** Whether the filtering operation completed successfully */\n  success: boolean;\n  /** The filtered processed resources, available if filtering succeeded */\n  processedResources?: ProcessedResources;\n  /** Analysis of individual resources after filtering, showing per-resource impact */\n  filteredResources: FilteredResource[];\n  /** Warning messages about potential filtering issues or edge cases */\n  warnings: string[];\n  /** Error message if the filtering operation failed */\n  error?: string;\n}\n\n// Orchestrator types\n/**\n * Complete state object for the resource orchestrator system.\n *\n * This interface represents the central state management for ts-res resources, encompassing\n * all aspects of resource processing, configuration, filtering, and resolution. It serves as\n * the primary state container for applications using the resource orchestrator.\n *\n * @example\n * ```typescript\n * // Basic usage with the orchestrator hook\n * import { ResourceTools } from '@fgv/ts-res-ui-components';\n *\n * function MyResourceApp() {\n *   const { state, actions } = ResourceTools.useResourceData();\n *\n *   // Check if resources are loaded\n *   if (!state.resources) {\n *     return <div>No resources loaded</div>;\n *   }\n *\n *   // Display current state information\n *   return (\n *     <div>\n *       <p>Resources: {state.resources.summary?.resourceCount || 0}</p>\n *       <p>Configuration: {state.configuration ? 'Loaded' : 'Default'}</p>\n *       <p>Processing: {state.isProcessing ? 'Yes' : 'No'}</p>\n *       <p>Selected: {state.selectedResourceId || 'None'}</p>\n *     </div>\n *   );\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Working with filter state\n * const { state } = ResourceTools.useResourceData();\n *\n * // Check if filters are applied\n * const hasActiveFilters = Object.keys(state.filterState.appliedValues).length > 0;\n * const filteredResourceCount = state.filterResult?.resources?.summary?.resourceCount || 0;\n *\n * console.log(`Filters active: ${hasActiveFilters}`);\n * console.log(`Filtered resources: ${filteredResourceCount}`);\n * ```\n *\n * @example\n * ```typescript\n * // Working with resolution state\n * const { state } = ResourceTools.useResourceData();\n *\n * // Check resolution context\n * const hasResolutionContext = Object.keys(state.resolutionState.context).length > 0;\n * const currentMode = state.resolutionState.viewMode;\n * const hasEdits = Object.keys(state.resolutionState.editedResources).length > 0;\n *\n * console.log(`Resolution mode: ${currentMode}`);\n * console.log(`Has context: ${hasResolutionContext}`);\n * console.log(`Has edits: ${hasEdits}`);\n * ```\n *\n * @public\n */\nexport interface OrchestratorState {\n  resources: ExtendedProcessedResources | null;\n  configuration: Config.Model.ISystemConfiguration | null;\n  filterState: FilterState;\n  filterResult: FilterResult | null;\n  resolutionState: ResolutionState;\n  selectedResourceId: string | null;\n  isProcessing: boolean;\n  error: string | null;\n  messages: Message[];\n}\n\n/**\n * Complete actions interface for the resource orchestrator system.\n *\n * This interface provides all the methods needed to manage and manipulate the orchestrator state,\n * including resource import/export, configuration management, filtering, resolution, and UI state.\n * All methods are designed to work seamlessly with the Result pattern for consistent error handling.\n *\n * @example\n * ```typescript\n * // Basic resource import workflow\n * import { ResourceTools, FileTools } from '@fgv/ts-res-ui-components';\n *\n * function ResourceImporter() {\n *   const { state, actions } = ResourceTools.useResourceData();\n *\n *   const handleDirectoryImport = async (files: File[]) => {\n *     const directory = await FileTools.convertFilesToDirectory(files);\n *     await actions.importDirectory(directory);\n *\n *     if (state.error) {\n *       console.error('Import failed:', state.error);\n *     } else {\n *       console.log('Import successful:', state.resources?.summary);\n *     }\n *   };\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Configuration and filtering workflow\n * const { state, actions } = ResourceTools.useResourceData();\n *\n * // Apply a new configuration\n * actions.applyConfiguration(customConfig);\n *\n * // Set up filters\n * actions.updateFilterState({\n *   values: { language: 'en-US', platform: 'web' }\n * });\n *\n * // Apply filters and get results\n * const filterResult = await actions.applyFilter();\n * if (filterResult) {\n *   console.log('Filtered resources:', filterResult.resources.summary.resourceCount);\n * }\n * ```\n *\n * @example\n * ```typescript\n * // Resolution context and resource editing\n * const { state, actions } = ResourceTools.useResourceData();\n *\n * // Set resolution context\n * actions.updateResolutionContext('language', 'en-US');\n * actions.updateResolutionContext('platform', 'mobile');\n * actions.applyResolutionContext();\n *\n * // Select a resource for resolution\n * actions.selectResourceForResolution('user.welcome');\n *\n * // Edit a resolved resource value\n * const newValue = { text: 'Updated welcome message' };\n * actions.saveResourceEdit('user.welcome', newValue);\n *\n * // Apply all pending changes (edits + new resources)\n * await actions.applyPendingResources();\n * ```\n *\n * @example\n * ```typescript\n * // Resource resolution and error handling\n * const { actions } = ResourceTools.useResourceData();\n *\n * const resolveUserMessage = async (messageId: string, userContext: Record<string, string>) => {\n *   const result = await actions.resolveResource(messageId, userContext);\n *\n *   if (result.isSuccess()) {\n *     console.log('Resolved message:', result.value);\n *     return result.value;\n *   } else {\n *     console.error('Resolution failed:', result.message);\n *     actions.addMessage('error', `Failed to resolve ${messageId}: ${result.message}`);\n *     return null;\n *   }\n * };\n * ```\n *\n * @example\n * ```typescript\n * // Bundle import and advanced workflows\n * const { actions } = ResourceTools.useResourceData();\n *\n * // Import from a pre-built bundle\n * const bundleData = await loadBundleFromUrl('/api/resources/bundle');\n * await actions.importBundle(bundleData);\n *\n * // Import directory with specific configuration\n * const directory = await loadResourceDirectory();\n * const customConfig = await loadConfiguration();\n * await actions.importDirectoryWithConfig(directory, customConfig);\n * ```\n *\n * @public\n */\nexport interface OrchestratorActions {\n  // Resource management\n  importDirectory: (directory: ImportedDirectory) => Promise<void>;\n  importDirectoryWithConfig: (\n    directory: ImportedDirectory,\n    config: Config.Model.ISystemConfiguration\n  ) => Promise<void>;\n  importFiles: (files: ImportedFile[]) => Promise<void>;\n  importBundle: (bundle: Bundle.IBundle) => Promise<void>;\n  clearResources: () => void;\n\n  // Configuration management\n  updateConfiguration: (config: Config.Model.ISystemConfiguration) => void;\n  applyConfiguration: (config: Config.Model.ISystemConfiguration) => void;\n\n  // Filter management\n  updateFilterState: (state: Partial<FilterState>) => void;\n  applyFilter: () => Promise<FilterResult | null>;\n  resetFilter: () => void;\n\n  // Resolution management\n  updateResolutionContext: (qualifierName: string, value: string | undefined) => void;\n  applyResolutionContext: () => void;\n  selectResourceForResolution: (resourceId: string) => void;\n  setResolutionViewMode: (mode: 'composed' | 'best' | 'all' | 'raw') => void;\n  resetResolutionCache: () => void;\n\n  // Resolution editing\n  saveResourceEdit: (resourceId: string, editedValue: JsonValue, originalValue?: JsonValue) => void;\n  getEditedValue: (resourceId: string) => JsonValue | undefined;\n  hasResourceEdit: (resourceId: string) => boolean;\n  clearResourceEdits: () => void;\n  // Removed: unified apply via applyPendingResources\n  discardResourceEdits: () => void;\n\n  // Resource creation actions (enhanced with atomic API and Result pattern return values)\n  createPendingResource: (params: CreatePendingResourceParams) => Result<void>;\n  startNewResource: (\n    params?: StartNewResourceParams\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  updateNewResourceId: (\n    id: string\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  selectResourceType: (\n    type: string\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  updateNewResourceJson: (\n    json: JsonValue\n  ) => Result<{ draft: ResolutionState['newResourceDraft']; diagnostics: string[] }>;\n  saveNewResourceAsPending: () => Result<{\n    pendingResources: Map<string, ResourceJson.Json.ILooseResourceDecl>;\n    diagnostics: string[];\n  }>;\n  cancelNewResource: () => void;\n  removePendingResource: (resourceId: string) => void;\n  markResourceForDeletion: (resourceId: string) => void;\n  applyPendingResources: () => Promise<\n    Result<{\n      appliedCount: number;\n      existingResourceEditCount: number;\n      pendingResourceEditCount: number;\n      newResourceCount: number;\n      deletionCount: number;\n    }>\n  >;\n  discardPendingResources: () => void;\n\n  // Combined pending changes actions removed in favor of unified applyPendingResources\n\n  // Export functionality\n  exportBundle: () => void;\n  exportSource: () => void;\n  exportCompiled: () => void;\n\n  // UI state management\n  selectResource: (resourceId: string | null) => void;\n  addMessage: (type: Message['type'], message: string) => void;\n  clearMessages: () => void;\n\n  // Observability context for diagnostic and user logging\n  o11y: import('../utils/observability').IObservabilityContext;\n\n  // Resource resolution\n  resolveResource: (resourceId: string, context?: Record<string, string>) => Result<JsonValue>;\n}\n\n// GridView types\n/**\n * Dropdown option for cell editing.\n *\n * @public\n */\nexport interface GridDropdownOption {\n  /** The value to store when this option is selected */\n  value: string;\n  /** The label to display for this option */\n  label: string;\n  /** Whether this option is disabled */\n  disabled?: boolean;\n}\n\n/**\n * Validation configuration for grid cells.\n *\n * @public\n */\nexport interface GridCellValidation {\n  /** Whether the field is required */\n  required?: boolean;\n  /** Regex pattern for validation */\n  pattern?: RegExp;\n  /** Minimum length for string values */\n  minLength?: number;\n  /** Maximum length for string values */\n  maxLength?: number;\n  /** Custom validation function that returns error message or null */\n  custom?: (value: JsonValue) => string | null;\n}\n\n/**\n * Configuration for a single column in a resource grid.\n * Defines how to extract, display, and edit values from resolved resources.\n *\n * @public\n */\nexport interface GridColumnDefinition {\n  /** Unique identifier for this column */\n  id: string;\n  /** Display title for the column header */\n  title: string;\n  /** Path to the property in the resolved resource value (JSONPath-like) */\n  dataPath: string | string[];\n  /** Optional fixed width for the column */\n  width?: number;\n  /** Whether this column can be sorted */\n  sortable?: boolean;\n  /** Whether values in this column can be edited */\n  editable?: boolean;\n  /** Type of cell editor to use */\n  cellType?: 'string' | 'boolean' | 'tristate' | 'dropdown' | 'custom';\n  /** Custom component for rendering cell content */\n  cellRenderer?: React.ComponentType<GridCellProps>;\n  /** Custom component for editing cell content */\n  cellEditor?: React.ComponentType<GridCellEditorProps>;\n  /** Validation configuration for this column */\n  validation?: GridCellValidation;\n  /** Options for dropdown/combobox cells */\n  dropdownOptions?: GridDropdownOption[] | (() => Promise<GridDropdownOption[]>);\n  /** Whether to allow custom values in dropdown (combobox behavior) */\n  allowCustomValue?: boolean;\n  /** Presentation mode for tristate cells */\n  triStatePresentation?: 'checkbox' | 'dropdown';\n  /** Custom labels for tristate values */\n  triStateLabels?: {\n    trueLabel: string;\n    falseLabel: string;\n    undefinedLabel: string;\n  };\n}\n\n/**\n * Props passed to custom grid cell renderers.\n *\n * @public\n */\nexport interface GridCellProps {\n  /** The extracted value for this cell */\n  value: JsonValue;\n  /** The resource ID for this row */\n  resourceId: string;\n  /** The column definition for this cell */\n  column: GridColumnDefinition;\n  /** The complete resolved resource value */\n  resolvedValue: JsonValue;\n  /** Whether this cell has been edited */\n  isEdited: boolean;\n  /** Additional CSS classes */\n  className?: string;\n}\n\n/**\n * Props passed to custom grid cell editors.\n *\n * @public\n */\nexport interface GridCellEditorProps extends GridCellProps {\n  /** The current edited value if any */\n  editedValue?: JsonValue;\n  /** Callback when the user saves an edit */\n  onSave: (resourceId: string, newValue: JsonValue, originalValue: JsonValue) => void;\n  /** Callback when the user cancels an edit */\n  onCancel: () => void;\n  /** Whether editing is currently disabled */\n  disabled?: boolean;\n}\n\n/**\n * Column mapping configuration for a specific resource type.\n * Defines how resources of a given type should be displayed in the grid.\n *\n * @public\n */\nexport interface ResourceTypeColumnMapping {\n  /** The resource type this mapping applies to */\n  resourceType: string;\n  /** Column definitions for this resource type */\n  columns: GridColumnDefinition[];\n  /** Optional default column for unmapped properties */\n  defaultColumn?: GridColumnDefinition;\n}\n\n/**\n * Custom resource selector for advanced filtering logic.\n * Allows hosts to define complex resource selection criteria.\n *\n * @public\n */\nexport interface CustomResourceSelector {\n  /** Unique identifier for this selector */\n  id: string;\n  /** Function that returns resource IDs to include in the grid */\n  select: (resources: ProcessedResources) => string[];\n  /** Optional display name for debugging/logging */\n  displayName?: string;\n}\n\n/**\n * Resource selection configuration for grid views.\n * Supports simple built-in selectors and custom selection logic.\n *\n * @public\n */\nexport type GridResourceSelector =\n  | { type: 'ids'; resourceIds: string[] }\n  | { type: 'prefix'; prefix: string }\n  | { type: 'suffix'; suffix: string }\n  | { type: 'resourceTypes'; types: string[] }\n  | { type: 'pattern'; pattern: string }\n  | { type: 'all' }\n  | { type: 'custom'; selector: CustomResourceSelector };\n\n/**\n * Presentation options for grid display.\n *\n * @public\n */\nexport interface GridPresentationOptions {\n  /** Enable sorting of grid rows */\n  enableSorting?: boolean;\n  /** Enable filtering of grid rows */\n  enableFiltering?: boolean;\n  /** Number of rows per page (0 for no pagination) */\n  pageSize?: number;\n  /** Whether to show row numbers */\n  showRowNumbers?: boolean;\n  /** Whether to show a summary row */\n  showSummaryRow?: boolean;\n  /** Additional CSS classes for the grid container */\n  className?: string;\n}\n\n/**\n * Configuration for a single grid instance.\n * Defines resource selection, column mapping, and presentation options.\n *\n * @public\n */\nexport interface GridViewInitParams {\n  /** Unique identifier for this grid */\n  id: string;\n  /** Display title for this grid */\n  title: string;\n  /** Optional description for this grid */\n  description?: string;\n  /** How to select resources for this grid */\n  resourceSelection: GridResourceSelector;\n  /** Column mappings for resource types in this grid */\n  columnMapping: ResourceTypeColumnMapping[];\n  /** Optional presentation overrides */\n  presentationOptions?: GridPresentationOptions;\n}\n\n/**\n * Props for the GridView component.\n * Displays a single grid instance with resource editing capabilities.\n *\n * @public\n */\nexport interface GridViewProps extends ViewBaseProps {\n  /** Grid configuration defining what and how to display */\n  gridConfig: GridViewInitParams;\n  /** The resource system for resolution */\n  resources?: ProcessedResources | null;\n  /** Current resolution state (shared with other views) */\n  resolutionState?: ResolutionState;\n  /** Actions for managing resolution state (shared with other views) */\n  resolutionActions?: ResolutionActions;\n  /** Available qualifiers for context building */\n  availableQualifiers?: string[];\n  /** Optional configuration for context controls */\n  contextOptions?: ResolutionContextOptions;\n  /** Optional filter state integration */\n  filterState?: FilterState;\n  /** Filter results if applied */\n  filterResult?: FilterResult | null;\n  /** Whether to show context controls (default: true) */\n  showContextControls?: boolean;\n  /** Whether to show change controls (default: true) */\n  showChangeControls?: boolean;\n}\n\n/**\n * Props for the MultiGridView component.\n * Container for multiple grid instances with shared context and batch operations.\n *\n * @public\n */\nexport interface MultiGridViewProps extends ViewBaseProps {\n  /** Multiple grid configurations to display */\n  gridConfigurations: GridViewInitParams[];\n  /** The resource system for all grids */\n  resources?: ProcessedResources | null;\n  /** Shared resolution state across all grids */\n  resolutionState?: ResolutionState;\n  /** Shared resolution actions across all grids */\n  resolutionActions?: ResolutionActions;\n  /** Available qualifiers for context building */\n  availableQualifiers?: string[];\n  /** Shared context options for all grids */\n  contextOptions?: ResolutionContextOptions;\n  /** Optional filter state integration */\n  filterState?: FilterState;\n  /** Filter results if applied */\n  filterResult?: FilterResult | null;\n  /** How to present the grid selector */\n  tabsPresentation?: 'tabs' | 'cards' | 'accordion' | 'dropdown';\n  /** ID of the initially active grid */\n  defaultActiveGrid?: string;\n  /** Whether users can reorder grid tabs */\n  allowGridReordering?: boolean;\n}\n\n// Export utility types\nexport type { Result } from '@fgv/ts-utils';\nexport type { JsonValue } from '@fgv/ts-json-base';\n\n// Resource selector utility functions\nexport {\n  getPendingAdditionsByType,\n  isPendingAddition,\n  deriveLeafId,\n  deriveFullId,\n  getPendingResourceTypes,\n  getPendingResourceStats,\n  validatePendingResourceKeys\n} from '../utils/resourceSelectors';\n"]}