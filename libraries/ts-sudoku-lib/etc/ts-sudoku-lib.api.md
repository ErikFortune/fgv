## API Report File for "@fgv/ts-sudoku-lib"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Brand } from '@fgv/ts-utils';
import { Converter } from '@fgv/ts-utils';
import { Result } from '@fgv/ts-utils';

// @public
export const allPuzzleTypes: PuzzleType[];

// Warning: (ae-unresolved-link) The @link reference could not be resolved: The package "@fgv/ts-sudoku-lib" does not have an export "PuzzleDescription"
//
// @internal
class AnyPuzzle {
    // (undocumented)
    static create(puzzle: IPuzzleDescription): Result<Puzzle>;
}

// @public
abstract class BaseHintProvider implements IHintProvider {
    protected constructor(config: IBaseHintProviderConfig);
    abstract canProvideHints(state: PuzzleState): boolean;
    protected createCellAction(cellId: CellId, action: ICellAction['action'], value?: number, reason?: string): ICellAction;
    protected createExplanation(level: ExplanationLevel, title: string, description: string, steps?: readonly string[], tips?: readonly string[]): IHintExplanation;
    protected createHint(cellActions: readonly ICellAction[], relevantCells: IRelevantCells, explanations: readonly IHintExplanation[], confidence?: ConfidenceLevel): IHint;
    protected createRelevantCells(primary: readonly CellId[], secondary?: readonly CellId[], affected?: readonly CellId[]): IRelevantCells;
    // (undocumented)
    protected readonly defaultConfidence: ConfidenceLevel;
    // (undocumented)
    readonly difficulty: DifficultyLevel;
    protected filterHints(hints: readonly IHint[], options?: IHintGenerationOptions): readonly IHint[];
    abstract generateHints(state: PuzzleState, options?: IHintGenerationOptions): Result<readonly IHint[]>;
    protected getCandidates(cellId: CellId, state: PuzzleState): number[];
    protected getEmptyCells(state: PuzzleState): CellId[];
    // (undocumented)
    readonly priority: number;
    // (undocumented)
    readonly techniqueId: TechniqueId;
    // (undocumented)
    readonly techniqueName: string;
    protected validateOptions(options?: IHintGenerationOptions): Result<void>;
}

// Warning: (ae-internal-missing-underscore) The name "Cage" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Cage implements ICage {
    // (undocumented)
    readonly cageType: CageType;
    // (undocumented)
    get cellIds(): CellId[];
    // (undocumented)
    protected readonly _cellIds: CellId[];
    // (undocumented)
    containedValues(state: PuzzleState): Set<number>;
    // (undocumented)
    containsCell(id: CellId): boolean;
    // (undocumented)
    containsValue(value: number, state: PuzzleState, ignore?: CellId[]): boolean;
    // (undocumented)
    static create(id: CageId, type: CageType, total: number, cells: CellId[]): Result<Cage>;
    // (undocumented)
    readonly id: CageId;
    // (undocumented)
    get numCells(): number;
    // (undocumented)
    toString(state?: PuzzleState): string;
    // (undocumented)
    readonly total: number;
}

// @public
export type CageId = Brand<string, 'CageId'>;

// @public
const cageId: Converter<CageId>;

// @public
export type CageType = 'row' | 'column' | 'section' | 'x' | 'killer';

// Warning: (ae-internal-missing-underscore) The name "Cell" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Cell implements ICellInit, ICell {
    constructor(init: ICellInit, cages: readonly Cage[]);
    // (undocumented)
    readonly cages: readonly Cage[];
    // (undocumented)
    readonly col: number;
    // (undocumented)
    hasValue(state: PuzzleState): boolean;
    // (undocumented)
    readonly id: CellId;
    // (undocumented)
    readonly immutable: boolean;
    // (undocumented)
    readonly immutableValue?: number;
    // (undocumented)
    isValid(state: PuzzleState): boolean;
    // (undocumented)
    isValidValue(value: number | undefined, state: PuzzleState): boolean;
    // (undocumented)
    readonly row: number;
    // (undocumented)
    toString(state?: PuzzleState): string;
    // (undocumented)
    update(value: number | undefined, notes: number[]): Result<ICellState>;
    // (undocumented)
    updateNotes(notes: number[], state: PuzzleState): Result<ICellState>;
    // (undocumented)
    updateValue(value: number | undefined, state: PuzzleState): Result<ICellState>;
}

// @public
type CellAction = 'set-value' | 'eliminate-candidate' | 'add-candidate' | 'highlight';

// @public
export type CellId = Brand<string, 'CellId'>;

// @public
const cellId: Converter<CellId>;

// @public
type ConfidenceLevel = Brand<1 | 2 | 3 | 4 | 5, 'ConfidenceLevel'>;

// @public
const ConfidenceLevels: {
    readonly LOW: ConfidenceLevel;
    readonly MEDIUM_LOW: ConfidenceLevel;
    readonly MEDIUM: ConfidenceLevel;
    readonly MEDIUM_HIGH: ConfidenceLevel;
    readonly HIGH: ConfidenceLevel;
};

declare namespace Converters {
    export {
        cageId,
        cellId,
        puzzleType,
        puzzleDescription
    }
}
export { Converters }

declare namespace Converters_2 {
    export {
        loadJsonPuzzlesFileSync,
        puzzlesFile
    }
}

// @public
class DefaultHintApplicator implements IHintApplicator {
    applyHint(hint: IHint, state: PuzzleState): Result<readonly ICellState[]>;
    validateHint(hint: IHint, state: PuzzleState): Result<void>;
}

// @public
type DifficultyLevel = 'beginner' | 'intermediate' | 'advanced' | 'expert';

// @public
class EducationalContent {
    static createBeginnerGuide(): string;
    static getDifficultyProgression(): readonly string[];
    static getGeneralSolvingTips(): readonly string[];
    static getTechniqueIntroduction(techniqueId: TechniqueId): Result<string>;
    static getTechniqueOverview(techniqueId: TechniqueId): Result<string>;
    static getTechniqueRelationships(techniqueId: TechniqueId): Result<readonly string[]>;
}

// @public
class ExplanationFormatter {
    static createLevelSummary(explanations: readonly IHintExplanation[]): string;
    static formatAllExplanations(explanations: readonly IHintExplanation[]): string;
    static formatExplanation(explanation: IHintExplanation, includeSteps?: boolean, includeTips?: boolean): string;
}

// @public
type ExplanationLevel = 'brief' | 'detailed' | 'educational';

// @public
class ExplanationRegistry {
    constructor();
    getExplanationAtLevel(hint: IHint, level: ExplanationLevel, state: PuzzleState): Result<IHintExplanation>;
    getExplanations(hint: IHint, state: PuzzleState): Result<readonly IHintExplanation[]>;
    registerProvider(provider: IHintExplanationProvider): Result<void>;
}

declare namespace File_2 {
    export {
        Converters_2 as Converters,
        Model
    }
}
export { File_2 as File }

// @public
class HiddenSinglesProvider extends BaseHintProvider {
    constructor();
    canProvideHints(state: PuzzleState): boolean;
    static create(): Result<HiddenSinglesProvider>;
    generateHints(state: PuzzleState, options?: IHintGenerationOptions): Result<readonly IHint[]>;
}

// @public
class HintRegistry implements IHintRegistry {
    constructor();
    clear(): Result<void>;
    static create(providers?: readonly IHintProvider[]): Result<HintRegistry>;
    generateAllHints(state: PuzzleState, options?: IHintGenerationOptions): Result<readonly IHint[]>;
    getBestHint(state: PuzzleState, options?: IHintGenerationOptions): Result<IHint>;
    getProvider(techniqueId: TechniqueId): Result<IHintProvider>;
    getProviders(options?: IHintGenerationOptions): readonly IHintProvider[];
    getProvidersByDifficulty(): Map<DifficultyLevel, readonly IHintProvider[]>;
    getRegisteredTechniques(): readonly TechniqueId[];
    hasProvider(techniqueId: TechniqueId): boolean;
    get providerCount(): number;
    registerProvider(provider: IHintProvider): Result<void>;
    unregisterProvider(techniqueId: TechniqueId): Result<void>;
}

declare namespace Hints {
    export {
        TechniqueId,
        ConfidenceLevel,
        CellAction,
        ExplanationLevel,
        DifficultyLevel,
        ICellAction,
        IRelevantCells,
        IHintExplanation,
        IHint,
        IHintGenerationOptions,
        TechniqueIds,
        ConfidenceLevels,
        IHintProvider,
        IHintRegistry,
        IHintExplanationProvider,
        IHintApplicator,
        IBaseHintProviderConfig,
        BaseHintProvider,
        HintRegistry,
        NakedSinglesProvider,
        HiddenSinglesProvider,
        ExplanationRegistry,
        ExplanationFormatter,
        EducationalContent,
        IHintSystemConfig,
        DefaultHintApplicator,
        HintSystem,
        IPuzzleSessionHintsConfig,
        PuzzleSessionHints
    }
}
export { Hints }

// @public
class HintSystem {
    constructor(registry: IHintRegistry, applicator: IHintApplicator, config: IHintSystemConfig);
    get applicator(): IHintApplicator;
    applyHint(hint: IHint, state: PuzzleState): Result<readonly ICellState[]>;
    get config(): IHintSystemConfig;
    static create(config?: IHintSystemConfig): Result<HintSystem>;
    formatHintExplanation(hint: IHint, level?: ExplanationLevel): string;
    generateHints(state: PuzzleState, options?: IHintGenerationOptions): Result<readonly IHint[]>;
    getBestHint(state: PuzzleState, options?: IHintGenerationOptions): Result<IHint>;
    getHintStatistics(state: PuzzleState): Result<{
        totalHints: number;
        hintsByTechnique: Map<string, number>;
        hintsByDifficulty: Map<string, number>;
    }>;
    getSystemSummary(): string;
    hasHints(state: PuzzleState): Result<boolean>;
    get registry(): IHintRegistry;
    validateHint(hint: IHint, state: PuzzleState): Result<void>;
}

// @public
interface IBaseHintProviderConfig {
    // (undocumented)
    readonly defaultConfidence?: ConfidenceLevel;
    // (undocumented)
    readonly difficulty: DifficultyLevel;
    // (undocumented)
    readonly priority: number;
    // (undocumented)
    readonly techniqueId: TechniqueId;
    // (undocumented)
    readonly techniqueName: string;
}

// @public
export interface ICage {
    readonly cageType: CageType;
    readonly cellIds: CellId[];
    containsCell(id: CellId): boolean;
    readonly id: CageId;
    readonly numCells: number;
    readonly total: number;
}

// @public
export interface ICell {
    readonly cages: readonly ICage[];
    readonly col: number;
    readonly id: CellId;
    readonly immutable: boolean;
    readonly immutableValue?: number;
    readonly row: number;
}

// @public
interface ICellAction {
    // (undocumented)
    readonly action: CellAction;
    // (undocumented)
    readonly cellId: CellId;
    // (undocumented)
    readonly reason?: string;
    // (undocumented)
    readonly value?: number;
}

// @public
export interface ICellContents {
    readonly notes: number[];
    readonly value?: number;
}

// Warning: (ae-internal-missing-underscore) The name "ICellInit" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ICellInit {
    // (undocumented)
    readonly col: number;
    // (undocumented)
    readonly id: CellId;
    // (undocumented)
    readonly immutableValue?: number;
    // (undocumented)
    readonly row: number;
}

// @public
export interface ICellState extends ICellContents {
    // (undocumented)
    readonly id: CellId;
}

// Warning: (ae-internal-missing-underscore) The name "ICellUpdate" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ICellUpdate {
    // (undocumented)
    from: ICellState;
    // (undocumented)
    to: ICellState;
}

// @public (undocumented)
export class Ids {
    // (undocumented)
    static cageId(from: string | ICage): Result<CageId>;
    // (undocumented)
    static cellId(spec: string | IRowColumn | ICell): Result<CellId>;
    // (undocumented)
    static cellIds(firstRow: number, numRows: number, firstCol: number, numCols: number): Result<CellId[]>;
    // (undocumented)
    static columnCageId(col: number): CageId;
    // (undocumented)
    static rowCageId(row: number): CageId;
    // (undocumented)
    static sectionCageId(row: number, col: number): CageId;
}

// @public
interface IHint {
    // (undocumented)
    readonly cellActions: readonly ICellAction[];
    // (undocumented)
    readonly confidence: ConfidenceLevel;
    // (undocumented)
    readonly difficulty: DifficultyLevel;
    // (undocumented)
    readonly explanations: readonly IHintExplanation[];
    // (undocumented)
    readonly priority: number;
    // (undocumented)
    readonly relevantCells: IRelevantCells;
    // (undocumented)
    readonly techniqueId: TechniqueId;
    // (undocumented)
    readonly techniqueName: string;
}

// @public
interface IHintApplicator {
    applyHint(hint: IHint, state: PuzzleState): Result<readonly ICellState[]>;
    validateHint(hint: IHint, state: PuzzleState): Result<void>;
}

// @public
interface IHintExplanation {
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly level: ExplanationLevel;
    // (undocumented)
    readonly steps?: readonly string[];
    // (undocumented)
    readonly tips?: readonly string[];
    // (undocumented)
    readonly title: string;
}

// @public
interface IHintExplanationProvider {
    generateExplanations(hint: IHint, state: PuzzleState): Result<readonly IHintExplanation[]>;
    readonly techniqueId: TechniqueId;
}

// @public
interface IHintGenerationOptions {
    // (undocumented)
    readonly enabledTechniques?: readonly TechniqueId[];
    // (undocumented)
    readonly explanationLevel?: ExplanationLevel;
    // (undocumented)
    readonly maxHints?: number;
    // (undocumented)
    readonly minConfidence?: ConfidenceLevel;
    // (undocumented)
    readonly preferredDifficulty?: DifficultyLevel;
}

// @public
interface IHintProvider {
    canProvideHints(state: PuzzleState): boolean;
    // (undocumented)
    readonly difficulty: DifficultyLevel;
    generateHints(state: PuzzleState, options?: IHintGenerationOptions): Result<readonly IHint[]>;
    // (undocumented)
    readonly priority: number;
    // (undocumented)
    readonly techniqueId: TechniqueId;
    // (undocumented)
    readonly techniqueName: string;
}

// @public
interface IHintRegistry {
    generateAllHints(state: PuzzleState, options?: IHintGenerationOptions): Result<readonly IHint[]>;
    getBestHint(state: PuzzleState, options?: IHintGenerationOptions): Result<IHint>;
    getProvider(techniqueId: TechniqueId): Result<IHintProvider>;
    getProviders(options?: IHintGenerationOptions): readonly IHintProvider[];
    getRegisteredTechniques(): readonly TechniqueId[];
    registerProvider(provider: IHintProvider): Result<void>;
    unregisterProvider(techniqueId: TechniqueId): Result<void>;
}

// @public
interface IHintSystemConfig {
    // (undocumented)
    readonly defaultExplanationLevel?: ExplanationLevel;
    // (undocumented)
    readonly enableHiddenSingles?: boolean;
    // (undocumented)
    readonly enableNakedSingles?: boolean;
}

// @public
export interface IPuzzleDescription {
    // (undocumented)
    cells: string;
    // (undocumented)
    cols: number;
    // (undocumented)
    description: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    level: number;
    // (undocumented)
    rows: number;
    // (undocumented)
    type: PuzzleType;
}

// @public
interface IPuzzleSessionHintsConfig extends IHintSystemConfig {
    // (undocumented)
    readonly cacheTimeoutMs?: number;
    // (undocumented)
    readonly maxCacheEntries?: number;
}

// @public
interface IPuzzlesFile {
    // (undocumented)
    puzzles: IPuzzleDescription[];
}

// Warning: (ae-internal-missing-underscore) The name "IPuzzleUpdate" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface IPuzzleUpdate {
    // (undocumented)
    cells: ICellUpdate[];
    // (undocumented)
    from: PuzzleState;
    // (undocumented)
    to: PuzzleState;
}

// @public
interface IRelevantCells {
    // (undocumented)
    readonly affected: readonly CellId[];
    // (undocumented)
    readonly primary: readonly CellId[];
    // (undocumented)
    readonly secondary: readonly CellId[];
}

// @public
export interface IRowColumn {
    // (undocumented)
    col: number;
    // (undocumented)
    row: number;
}

// Warning: (ae-incompatible-release-tags) The symbol "KillerSudokuPuzzle" is marked as @public, but its signature references "Puzzle" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "KillerSudokuPuzzle" is marked as @public, but its signature references "Puzzle" which is marked as @internal
//
// @public (undocumented)
class KillerSudokuPuzzle extends Puzzle {
    // (undocumented)
    static create(desc: IPuzzleDescription): Result<Puzzle>;
}

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
function loadJsonPuzzlesFileSync(path: string): Result<IPuzzlesFile>;

declare namespace Model {
    export {
        IPuzzlesFile
    }
}

// @public
class NakedSinglesProvider extends BaseHintProvider {
    constructor();
    canProvideHints(state: PuzzleState): boolean;
    static create(): Result<NakedSinglesProvider>;
    generateHints(state: PuzzleState, options?: IHintGenerationOptions): Result<readonly IHint[]>;
}

// @public
export type NavigationDirection = 'down' | 'left' | 'right' | 'up';

// @public
export type NavigationWrap = 'none' | 'wrap-around' | 'wrap-next';

// Warning: (ae-internal-missing-underscore) The name "Puzzle" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Puzzle {
    protected constructor(puzzle: IPuzzleDescription, extraCages?: [CageId, Cage][]);
    // (undocumented)
    get cages(): Cage[];
    // (undocumented)
    protected readonly _cages: Map<CageId, Cage>;
    // (undocumented)
    get cells(): Cell[];
    // (undocumented)
    protected readonly _cells: Map<CellId, Cell>;
    // (undocumented)
    checkIsSolved(state: PuzzleState): boolean;
    // (undocumented)
    checkIsValid(state: PuzzleState): boolean;
    // (undocumented)
    get cols(): Cage[];
    // (undocumented)
    protected readonly _columns: Map<CageId, Cage>;
    // (undocumented)
    protected static _createColumnCages(numRows: number, numCols: number): Result<[CageId, Cage][]>;
    // (undocumented)
    protected static _createRowCages(numRows: number, numCols: number): Result<[CageId, Cage][]>;
    // (undocumented)
    readonly description: string;
    // (undocumented)
    getCage(id: CageId): Result<Cage>;
    // (undocumented)
    getCell(spec: string | IRowColumn | ICell): Result<Cell>;
    // (undocumented)
    getCellContents(spec: string | IRowColumn, state: PuzzleState): Result<{
        cell: Cell;
        contents: ICellContents;
    }>;
    // (undocumented)
    getCellNeighbor(spec: string | IRowColumn | ICell, direction: NavigationDirection, wrap: NavigationWrap): Result<ICell>;
    // (undocumented)
    getColumn(col: CageId | number): Result<Cage>;
    // (undocumented)
    getEmptyCells(state: PuzzleState): Cell[];
    // (undocumented)
    getInvalidCells(state: PuzzleState): Cell[];
    // (undocumented)
    getRow(row: CageId | number): Result<Cage>;
    // (undocumented)
    getSection(spec: CageId | IRowColumn): Result<Cage>;
    // (undocumented)
    readonly id?: string;
    // (undocumented)
    readonly initialState: PuzzleState;
    // (undocumented)
    get numColumns(): number;
    // (undocumented)
    get numRows(): number;
    // (undocumented)
    get rows(): Cage[];
    // (undocumented)
    protected readonly _rows: Map<CageId, Cage>;
    // (undocumented)
    get sections(): Cage[];
    // (undocumented)
    protected readonly _sections: Map<CageId, Cage>;
    // (undocumented)
    toString(state: PuzzleState): string;
    // (undocumented)
    toStrings(state: PuzzleState): string[];
    // (undocumented)
    updateCellNotes(want: string | IRowColumn, notes: number[], state: PuzzleState): Result<IPuzzleUpdate>;
    // (undocumented)
    updateCellValue(want: string | IRowColumn, value: number | undefined, state: PuzzleState): Result<IPuzzleUpdate>;
    // (undocumented)
    updateContents(wantUpdates: ICellState[] | ICellState, state: PuzzleState): Result<IPuzzleUpdate>;
    // (undocumented)
    updateNotes(wantUpdates: ICellState[] | ICellState, state: PuzzleState): Result<IPuzzleUpdate>;
    // (undocumented)
    updateValues(wantUpdates: ICellState[] | ICellState, state: PuzzleState): Result<IPuzzleUpdate>;
}

// @public
export class PuzzleCollection {
    // Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
    // Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
    static create(from: File_2.Model.IPuzzlesFile): Result<PuzzleCollection>;
    getDescription(id: string): Result<IPuzzleDescription>;
    getPuzzle(id: string): Result<PuzzleSession>;
    static load(path: string): Result<PuzzleCollection>;
    readonly puzzles: readonly IPuzzleDescription[];
}

// @public
export class PuzzleCollections {
    static get default(): PuzzleCollection;
}

// @public
const puzzleDescription: Converter<IPuzzleDescription>;

declare namespace Puzzles {
    export {
        AnyPuzzle as Any,
        KillerSudokuPuzzle as Killer,
        SudokuPuzzle as Sudoku,
        SudokuXPuzzle as SudokuX
    }
}
export { Puzzles }

// @public
export class PuzzleSession {
    // @internal
    protected constructor(puzzle: Puzzle);
    cageContainedValues(spec: string | ICage): Set<number>;
    cageContainsValue(spec: string | ICage, value: number): boolean;
    get cages(): ICage[];
    get canRedo(): boolean;
    get canUndo(): boolean;
    cellHasValue(spec: string | IRowColumn | ICell): boolean;
    cellIsValid(spec: string | IRowColumn | ICell): boolean;
    get cells(): ICell[];
    checkIsSolved(): boolean;
    checkIsValid(): boolean;
    get cols(): ICage[];
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "Puzzle" which is marked as @internal
    static create(puzzle: Puzzle): Result<PuzzleSession>;
    get description(): string;
    getCellContents(spec: string | IRowColumn): Result<{
        cell: ICell;
        contents: ICellContents;
    }>;
    getCellNeighbor(spec: string | IRowColumn | ICell, direction: NavigationDirection, wrap: NavigationWrap): Result<ICell>;
    getEmptyCells(): ICell[];
    getInvalidCells(): ICell[];
    get id(): string | undefined;
    isValidForCell(spec: string | IRowColumn | ICell, value: number): boolean;
    get nextStep(): number;
    // (undocumented)
    protected _nextStep: number;
    get numColumns(): number;
    get numRows(): number;
    get numSteps(): number;
    // (undocumented)
    protected _numSteps: number;
    // Warning: (ae-incompatible-release-tags) The symbol "_puzzle" is marked as @public, but its signature references "Puzzle" which is marked as @internal
    //
    // (undocumented)
    protected readonly _puzzle: Puzzle;
    redo(): Result<this>;
    get rows(): ICage[];
    get sections(): ICage[];
    state: PuzzleState;
    // Warning: (ae-forgotten-export) The symbol "IPuzzleStep" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _steps: IPuzzleStep[];
    toStrings(): string[];
    undo(): Result<this>;
    updateCellNotes(spec: string | IRowColumn | ICell, notes: number[]): Result<this>;
    updateCells(updates: ICellState[]): Result<this>;
    updateCellValue(spec: string | IRowColumn | ICell, value: number | undefined): Result<this>;
}

// @public
class PuzzleSessionHints {
    applyHint(hint: IHint): Result<this>;
    cageContainedValues(spec: string | ICage): Set<number>;
    cageContainsValue(spec: string | ICage, value: number): boolean;
    get cages(): ICage[];
    get canRedo(): boolean;
    get canUndo(): boolean;
    cellHasValue(spec: string | IRowColumn | ICell): boolean;
    cellIsValid(spec: string | IRowColumn | ICell): boolean;
    get cells(): ICell[];
    checkIsSolved(): boolean;
    checkIsValid(): boolean;
    get cols(): ICage[];
    get config(): IPuzzleSessionHintsConfig;
    static create(session: PuzzleSession, config?: IPuzzleSessionHintsConfig): Result<PuzzleSessionHints>;
    get description(): string;
    getAllHints(options?: IHintGenerationOptions): Result<readonly IHint[]>;
    getCellContents(spec: string | IRowColumn): Result<{
        cell: ICell;
        contents: ICellContents;
    }>;
    getCellNeighbor(spec: string | IRowColumn | ICell, direction: NavigationDirection, wrap: NavigationWrap): Result<ICell>;
    getEmptyCells(): ICell[];
    getExplanation(hint: IHint, level?: ExplanationLevel): string;
    getHint(options?: IHintGenerationOptions): Result<IHint>;
    getHintsForCell(spec: string | IRowColumn | ICell, options?: IHintGenerationOptions): Result<readonly IHint[]>;
    getHintStatistics(options?: IHintGenerationOptions): Result<{
        totalHints: number;
        hintsByTechnique: Map<string, number>;
        hintsByDifficulty: Map<string, number>;
    }>;
    getInvalidCells(): ICell[];
    getSystemSummary(): string;
    hasHints(options?: IHintGenerationOptions): Result<boolean>;
    get hintSystem(): HintSystem;
    get id(): string | undefined;
    isValidForCell(spec: string | IRowColumn | ICell, value: number): boolean;
    get nextStep(): number;
    get numColumns(): number;
    get numRows(): number;
    get numSteps(): number;
    redo(): Result<this>;
    get rows(): ICage[];
    get sections(): ICage[];
    get session(): PuzzleSession;
    get state(): PuzzleState;
    toStrings(): string[];
    undo(): Result<this>;
    updateCellNotes(spec: string | IRowColumn | ICell, notes: number[]): Result<this>;
    updateCells(updates: ICellState[]): Result<this>;
    updateCellValue(spec: string | IRowColumn | ICell, value: number | undefined): Result<this>;
    validateHint(hint: IHint): Result<void>;
}

// Warning: (ae-unresolved-link) The @link reference could not be resolved: This type of declaration is not supported yet by the resolver
//
// @public
const puzzlesFile: Converter<IPuzzlesFile>;

// @public (undocumented)
export class PuzzleState {
    // @internal
    protected constructor(from: Map<CellId, ICellContents>, updates?: ICellState[]);
    // @internal (undocumented)
    protected readonly _cells: Map<CellId, ICellContents>;
    static create(cells: ICellState[]): Result<PuzzleState>;
    getCellContents(id: CellId): Result<ICellContents>;
    hasValue(id: CellId): boolean;
    // @internal
    protected static _toEntries(states?: ICellState[]): [CellId, ICellContents][];
    update(updates: ICellState[]): Result<PuzzleState>;
}

// @public
export type PuzzleType = 'killer-sudoku' | 'sudoku' | 'sudoku-x';

// @public
const puzzleType: Converter<PuzzleType, ReadonlyArray<PuzzleType>>;

// Warning: (ae-incompatible-release-tags) The symbol "SudokuPuzzle" is marked as @public, but its signature references "Puzzle" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "SudokuPuzzle" is marked as @public, but its signature references "Puzzle" which is marked as @internal
//
// @public (undocumented)
class SudokuPuzzle extends Puzzle {
    // (undocumented)
    static create(puzzle: IPuzzleDescription): Result<Puzzle>;
}

// Warning: (ae-incompatible-release-tags) The symbol "SudokuXPuzzle" is marked as @public, but its signature references "Puzzle" which is marked as @internal
// Warning: (ae-incompatible-release-tags) The symbol "SudokuXPuzzle" is marked as @public, but its signature references "Puzzle" which is marked as @internal
//
// @public (undocumented)
class SudokuXPuzzle extends Puzzle {
    // (undocumented)
    static create(puzzle: IPuzzleDescription): Result<Puzzle>;
}

// @public
type TechniqueId = Brand<string, 'TechniqueId'>;

// @public
const TechniqueIds: {
    readonly NAKED_SINGLES: TechniqueId;
    readonly HIDDEN_SINGLES: TechniqueId;
};

// @public
export const totalsByCageSize: readonly {
    min: number;
    max: number;
}[];

// (No @packageDocumentation comment for this package)

```
