/*
 * MIT License
 *
 * Copyright (c) 2023 Erik Fortune
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import '@fgv/ts-utils-jest';
import { HiddenSinglesProvider } from '../../../packlets/hints/hiddenSingles';
import { PuzzleState } from '../../../packlets/common/puzzleState';
import { PuzzleSession } from '../../../packlets/common/puzzleSession';
import { Puzzles, IPuzzleDescription, PuzzleType } from '../../../index';
import { ConfidenceLevels, TechniqueIds } from '../../../packlets/hints/types';

describe('HiddenSinglesProvider', () => {
  let provider: HiddenSinglesProvider;

  beforeEach(() => {
    provider = HiddenSinglesProvider.create().orThrow();
  });

  describe('creation', () => {
    test('should create successfully', () => {
      expect(HiddenSinglesProvider.create()).toSucceed();
    });

    test('should have correct technique properties', () => {
      expect(provider.techniqueId).toBe(TechniqueIds.HIDDEN_SINGLES);
      expect(provider.techniqueName).toBe('Hidden Singles');
      expect(provider.difficulty).toBe('beginner');
      expect(provider.priority).toBe(2);
    });
  });

  describe('canProvideHints', () => {
    test('should return true for puzzle with empty cells', () => {
      const puzzle = createTestPuzzle([
        '1........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.canProvideHints(state)).toBe(true);
    });

    test('should return false for completely filled puzzle', () => {
      const puzzle = createTestPuzzle([
        '123456789',
        '456789123',
        '789123456',
        '234567891',
        '567891234',
        '891234567',
        '345678912',
        '678912345',
        '912345678'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.canProvideHints(state)).toBe(false);
    });
  });

  describe('generateHints - hidden singles in rows', () => {
    test('should detect hidden single where value can only go in one cell in row', () => {
      // Create a scenario where 9 can only go in r0c0 in row 0
      const rowPuzzle = createTestPuzzle([
        '.9.......', // 9 is placed in column 1
        '..9......', // 9 is placed in column 2
        '...9.....',  // 9 is placed in column 3
        '....9....',  // 9 is placed in column 4
        '.....9...',  // 9 is placed in column 5
        '......9..',  // 9 is placed in column 6
        '.......9.',  // 9 is placed in column 7
        '........9',  // 9 is placed in column 8
        '1........'   // Column 0 has other constraint, so r0c0 is only place for 9 in row 0
      ]);
      const state = createPuzzleState(rowPuzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        // Look for a hidden single where 9 goes in cell r0c0
        const hiddenSingleHint = hints.find(hint =>
          hint.cellActions[0].cellId === 'r0c0' && hint.cellActions[0].value === 9
        );
        expect(hiddenSingleHint).toBeDefined();

        if (hiddenSingleHint) {
          expect(hiddenSingleHint.techniqueId).toBe(TechniqueIds.HIDDEN_SINGLES);
          expect(hiddenSingleHint.confidence).toBe(ConfidenceLevels.HIGH);
          expect(hiddenSingleHint.cellActions[0].action).toBe('set-value');
        }
      });
    });

    test('should create proper explanations for row-based hidden singles', () => {
      const puzzle = createTestPuzzle([
        '.9.......',
        '..9......',
        '...9.....',
        '....9....',
        '.....9...',
        '......9..',
        '.......9.',
        '........9',
        '1........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        const hint = hints.find(h => h.cellActions[0].value === 9);
        if (hint) {
          const briefExplanation = hint.explanations.find(exp => exp.level === 'brief');
          expect(briefExplanation?.description).toContain('row');
          expect(briefExplanation?.description).toContain('can only go in');
        }
      });
    });
  });

  describe('generateHints - hidden singles in columns', () => {
    test('should detect hidden single where value can only go in one cell in column', () => {
      // Create a scenario where 8 can only go in one cell in column 0
      const puzzle = createTestPuzzle([
        '8........',  // 8 in row 0
        '.8.......',  // 8 in row 1
        '..8......',  // 8 in row 2
        '...8.....',  // 8 in row 3
        '....8....',  // 8 in row 4
        '.....8...',  // 8 in row 5
        '......8..',  // 8 in row 6
        '.......8.',  // 8 in row 7
        '.........'   // Only row 8 missing 8, so r8c0 must contain 8
      ]);

      // But we need to make sure 8 can only go in one cell in column 0
      // Add constraints so that only r8c0 can contain 8 in column 0
      const modifiedPuzzle = createTestPuzzle([
        '1........',  // Different value in r0c0
        '2........',  // Different value in r1c0
        '3........',  // Different value in r2c0
        '4........',  // Different value in r3c0
        '5........',  // Different value in r4c0
        '6........',  // Different value in r5c0
        '7........',  // Different value in r6c0
        '9........',  // Different value in r7c0
        '.8.......'   // r8c0 is empty, r8c1 has 8
      ]);

      const state = createPuzzleState(modifiedPuzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        const hiddenSingle = hints.find(hint =>
          hint.cellActions[0].cellId === 'r8c0' && hint.cellActions[0].value === 8
        );

        if (hiddenSingle) {
          expect(hiddenSingle.techniqueId).toBe(TechniqueIds.HIDDEN_SINGLES);
          const explanation = hiddenSingle.explanations.find(exp => exp.level === 'brief');
          expect(explanation?.description).toContain('column');
        }
      });
    });
  });

  describe('generateHints - hidden singles in boxes', () => {
    test('should detect hidden single where value can only go in one cell in 3x3 box', () => {
      // Create a scenario where 7 can only go in one cell in the top-left box
      const puzzle = createTestPuzzle([
        '123......',  // Top-left box has 1,2,3
        '456......',  // Top-left box has 4,5,6
        '78.......', // Top-left box has 7,8, leaving only r2c2 for 9
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        const boxHiddenSingle = hints.find(hint =>
          hint.cellActions[0].cellId === 'r2c2' && hint.cellActions[0].value === 9
        );

        if (boxHiddenSingle) {
          expect(boxHiddenSingle.techniqueId).toBe(TechniqueIds.HIDDEN_SINGLES);
          const explanation = boxHiddenSingle.explanations.find(exp => exp.level === 'brief');
          expect(explanation?.description).toContain('box');
        }
      });
    });

    test('should correctly identify different 3x3 boxes', () => {
      // Test middle box (box index 4)
      const puzzle = createTestPuzzle([
        '.........',
        '.........',
        '.........',
        '...123...',  // Middle box has 1,2,3
        '...456...',  // Middle box has 4,5,6
        '...78....',  // Middle box has 7,8, leaving r5c5 for 9
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        const boxHiddenSingle = hints.find(hint =>
          hint.cellActions[0].cellId === 'r5c5' && hint.cellActions[0].value === 9
        );

        expect(boxHiddenSingle).toBeDefined();
        if (boxHiddenSingle) {
          const explanation = boxHiddenSingle.explanations.find(exp => exp.level === 'detailed');
          expect(explanation?.description).toContain('box');
        }
      });
    });
  });

  describe('generateHints - duplicate removal', () => {
    test('should remove duplicate hidden singles found in multiple units', () => {
      // Create a scenario where the same cell+value combination
      // might be found as hidden single in multiple units
      const puzzle = createTestPuzzle([
        '12345678.',  // r0c8 is constrained
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '........9'   // This creates constraints that might lead to duplicates
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        // Check for duplicates by cell+value combination
        const cellValuePairs = hints.map(hint =>
          `${hint.cellActions[0].cellId}-${hint.cellActions[0].value}`
        );
        const uniquePairs = new Set(cellValuePairs);

        expect(cellValuePairs.length).toBe(uniquePairs.size);
      });
    });
  });

  describe('generateHints - complex scenarios', () => {
    test('should find multiple hidden singles in different units', () => {
      // Create a more complex puzzle with multiple hidden singles
      const puzzle = createTestPuzzle([
        '12345678.',  // Row constraint creates hidden single
        '.........',
        '.........',
        '1........',  // Column constraint
        '2........',  // Column constraint
        '3........',  // Column constraint
        '4........',  // Column constraint
        '5........',  // Column constraint
        '6........'   // This leaves hidden singles in column 0
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        expect(hints.length).toBeGreaterThan(0);

        // All should be valid hidden singles
        for (const hint of hints) {
          expect(hint.techniqueId).toBe(TechniqueIds.HIDDEN_SINGLES);
          expect(hint.confidence).toBe(ConfidenceLevels.HIGH);
          expect(hint.cellActions).toHaveLength(1);
          expect(hint.cellActions[0].action).toBe('set-value');
        }
      });
    });

    test('should handle case where no hidden singles exist', () => {
      // Create a minimal puzzle where no hidden singles are obvious
      const puzzle = createTestPuzzle([
        '1........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        // May or may not find hidden singles depending on puzzle state
        // This is not an error case - just validates the method doesn't crash
        expect(Array.isArray(hints)).toBe(true);
      });
    });
  });

  describe('hint structure validation', () => {
    test('should create well-formed hidden single hints', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        if (hints.length > 0) {
          const hint = hints[0];

          // Verify hint structure
          expect(hint.techniqueId).toBe(TechniqueIds.HIDDEN_SINGLES);
          expect(hint.techniqueName).toBe('Hidden Singles');
          expect(hint.difficulty).toBe('beginner');
          expect(hint.confidence).toBe(ConfidenceLevels.HIGH);
          expect(hint.priority).toBe(2);

          // Verify cell actions
          expect(hint.cellActions).toHaveLength(1);
          expect(hint.cellActions[0].action).toBe('set-value');
          expect(hint.cellActions[0].value).toBeGreaterThanOrEqual(1);
          expect(hint.cellActions[0].value).toBeLessThanOrEqual(9);
          expect(hint.cellActions[0].reason).toContain('Only cell in');

          // Verify relevant cells
          expect(hint.relevantCells.primary).toHaveLength(1);
          expect(hint.relevantCells.primary[0]).toBe(hint.cellActions[0].cellId);
          expect(hint.relevantCells.affected).toHaveLength(0);

          // Verify explanations
          expect(hint.explanations).toHaveLength(3);
          const levels = hint.explanations.map(exp => exp.level);
          expect(levels).toContain('brief');
          expect(levels).toContain('detailed');
          expect(levels).toContain('educational');
        }
      });
    });

    test('should include other candidate cells in relevant cells', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        if (hints.length > 0) {
          const hint = hints[0];

          // Secondary cells should include other empty cells in the same unit
          expect(hint.relevantCells.secondary.length).toBeGreaterThanOrEqual(0);

          // All secondary cells should be empty
          for (const cellId of hint.relevantCells.secondary) {
            expect(state.hasValue(cellId)).toBe(false);
          }
        }
      });
    });
  });

  describe('explanation content validation', () => {
    test('should provide accurate brief explanations with unit information', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        if (hints.length > 0) {
          const hint = hints[0];
          const briefExplanation = hint.explanations.find(exp => exp.level === 'brief');
          expect(briefExplanation).toBeDefined();

          expect(briefExplanation!.title).toBe('Hidden Single');
          expect(briefExplanation!.description).toMatch(/In (row|column|box) \d+.*can only go in cell/);
          expect(briefExplanation!.steps).toContain(`Set ${hint.cellActions[0].cellId} = ${hint.cellActions[0].value}`);
          expect(briefExplanation!.tips).toContain('Look for values that can only go in one cell within a unit');
        }
      });
    });

    test('should provide detailed explanations with analysis steps', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        if (hints.length > 0) {
          const hint = hints[0];
          const detailedExplanation = hint.explanations.find(exp => exp.level === 'detailed');
          expect(detailedExplanation).toBeDefined();

          expect(detailedExplanation!.title).toBe('Hidden Single Analysis');
          expect(detailedExplanation!.description).toContain('can only be placed in cell');
          expect(detailedExplanation!.steps).toHaveLength(5);
          expect(detailedExplanation!.tips).toHaveLength(3);
          expect(detailedExplanation!.tips![0]).toContain('focus on where a value can go');
        }
      });
    });

    test('should provide educational explanations with learning context', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state)).toSucceedAndSatisfy((hints) => {
        if (hints.length > 0) {
          const hint = hints[0];
          const educationalExplanation = hint.explanations.find(exp => exp.level === 'educational');
          expect(educationalExplanation).toBeDefined();

          expect(educationalExplanation!.title).toBe('Understanding Hidden Singles');
          expect(educationalExplanation!.description).toContain('hidden single occurs when');
          expect(educationalExplanation!.description).toContain('called "hidden" because');
          expect(educationalExplanation!.steps).toHaveLength(7);
          expect(educationalExplanation!.tips).toHaveLength(4);
          expect(educationalExplanation!.tips![0]).toContain('complement naked singles');
        }
      });
    });
  });

  describe('option handling', () => {
    test('should respect maxHints option', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state, { maxHints: 1 })).toSucceedAndSatisfy((hints) => {
        expect(hints.length).toBeLessThanOrEqual(1);
      });
    });

    test('should respect minConfidence option', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      expect(provider.generateHints(state, { minConfidence: ConfidenceLevels.HIGH }))
        .toSucceedAndSatisfy((hints) => {
          for (const hint of hints) {
            expect(hint.confidence).toBeGreaterThanOrEqual(ConfidenceLevels.HIGH);
          }
        });
    });

    test('should filter by enabled techniques', () => {
      const puzzle = createTestPuzzle([
        '12345678.',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........',
        '.........'
      ]);
      const state = createPuzzleState(puzzle);

      // Should return hints when technique is enabled
      expect(provider.generateHints(state, { enabledTechniques: [TechniqueIds.HIDDEN_SINGLES] }))
        .toSucceedAndSatisfy((hints) => {
          for (const hint of hints) {
            expect(hint.techniqueId).toBe(TechniqueIds.HIDDEN_SINGLES);
          }
        });

      // Should return no hints when technique is not enabled
      expect(provider.generateHints(state, { enabledTechniques: [TechniqueIds.NAKED_SINGLES] }))
        .toSucceedAndSatisfy((hints) => {
          expect(hints).toHaveLength(0);
        });
    });
  });
});

// Helper functions for creating test puzzles and states
function createTestPuzzle(rows: string[]): IPuzzleDescription {
  return {
    id: 'test-puzzle',
    description: 'Test puzzle for hidden singles',
    type: 'sudoku' as PuzzleType,
    level: 1,
    rows: 9,
    cols: 9,
    cells: rows.join('')
  };
}

function createPuzzleState(puzzleDesc: IPuzzleDescription): PuzzleState {
  const puzzle = Puzzles.Any.create(puzzleDesc).orThrow();
  const session = PuzzleSession.create(puzzle).orThrow();
  return session.state;
}